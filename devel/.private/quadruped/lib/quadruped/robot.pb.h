// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_robot_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "geometry.pb.h"
#include "std.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_robot_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_robot_2eproto;
namespace robot_msg {
class FootPhase;
struct FootPhaseDefaultTypeInternal;
extern FootPhaseDefaultTypeInternal _FootPhase_default_instance_;
class FootPrint;
struct FootPrintDefaultTypeInternal;
extern FootPrintDefaultTypeInternal _FootPrint_default_instance_;
class GaitInfo;
struct GaitInfoDefaultTypeInternal;
extern GaitInfoDefaultTypeInternal _GaitInfo_default_instance_;
class GaitReply;
struct GaitReplyDefaultTypeInternal;
extern GaitReplyDefaultTypeInternal _GaitReply_default_instance_;
class GaitRequest;
struct GaitRequestDefaultTypeInternal;
extern GaitRequestDefaultTypeInternal _GaitRequest_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class StateStamped;
struct StateStampedDefaultTypeInternal;
extern StateStampedDefaultTypeInternal _StateStamped_default_instance_;
class StateStampedWithCovariance;
struct StateStampedWithCovarianceDefaultTypeInternal;
extern StateStampedWithCovarianceDefaultTypeInternal _StateStampedWithCovariance_default_instance_;
class StateWithCovariance;
struct StateWithCovarianceDefaultTypeInternal;
extern StateWithCovarianceDefaultTypeInternal _StateWithCovariance_default_instance_;
}  // namespace robot_msg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace robot_msg {
enum GAIT : int {
  STOP = 0,
  STANCE = 1,
  WALK = 2,
  TROT = 3,
  CONGNITIVE = 4,
  GAIT_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GAIT_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GAIT_IsValid(int value);
extern const uint32_t GAIT_internal_data_[];
constexpr GAIT GAIT_MIN = static_cast<GAIT>(0);
constexpr GAIT GAIT_MAX = static_cast<GAIT>(4);
constexpr int GAIT_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
GAIT_descriptor();
template <typename T>
const std::string& GAIT_Name(T value) {
  static_assert(std::is_same<T, GAIT>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GAIT_Name().");
  return GAIT_Name(static_cast<GAIT>(value));
}
template <>
inline const std::string& GAIT_Name(GAIT value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GAIT_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool GAIT_Parse(absl::string_view name, GAIT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GAIT>(
      GAIT_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class GaitRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.GaitRequest) */ {
 public:
  inline GaitRequest() : GaitRequest(nullptr) {}
  ~GaitRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GaitRequest(::google::protobuf::internal::ConstantInitialized);

  inline GaitRequest(const GaitRequest& from)
      : GaitRequest(nullptr, from) {}
  GaitRequest(GaitRequest&& from) noexcept
    : GaitRequest() {
    *this = ::std::move(from);
  }

  inline GaitRequest& operator=(const GaitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GaitRequest& operator=(GaitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GaitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GaitRequest* internal_default_instance() {
    return reinterpret_cast<const GaitRequest*>(
               &_GaitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GaitRequest& a, GaitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GaitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GaitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GaitRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GaitRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GaitRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GaitRequest& from) {
    GaitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GaitRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.GaitRequest";
  }
  protected:
  explicit GaitRequest(::google::protobuf::Arena* arena);
  GaitRequest(::google::protobuf::Arena* arena, const GaitRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZetaFieldNumber = 2,
    kStanceheightFieldNumber = 3,
    kLiftheightFieldNumber = 4,
    kSteplengthFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // double zeta = 2;
  void clear_zeta() ;
  double zeta() const;
  void set_zeta(double value);

  private:
  double _internal_zeta() const;
  void _internal_set_zeta(double value);

  public:
  // double stanceheight = 3;
  void clear_stanceheight() ;
  double stanceheight() const;
  void set_stanceheight(double value);

  private:
  double _internal_stanceheight() const;
  void _internal_set_stanceheight(double value);

  public:
  // double liftheight = 4;
  void clear_liftheight() ;
  double liftheight() const;
  void set_liftheight(double value);

  private:
  double _internal_liftheight() const;
  void _internal_set_liftheight(double value);

  public:
  // double steplength = 5;
  void clear_steplength() ;
  double steplength() const;
  void set_steplength(double value);

  private:
  double _internal_steplength() const;
  void _internal_set_steplength(double value);

  public:
  // .robot_msg.GAIT type = 1;
  void clear_type() ;
  ::robot_msg::GAIT type() const;
  void set_type(::robot_msg::GAIT value);

  private:
  ::robot_msg::GAIT _internal_type() const;
  void _internal_set_type(::robot_msg::GAIT value);

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.GaitRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double zeta_;
    double stanceheight_;
    double liftheight_;
    double steplength_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class GaitReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.GaitReply) */ {
 public:
  inline GaitReply() : GaitReply(nullptr) {}
  ~GaitReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GaitReply(::google::protobuf::internal::ConstantInitialized);

  inline GaitReply(const GaitReply& from)
      : GaitReply(nullptr, from) {}
  GaitReply(GaitReply&& from) noexcept
    : GaitReply() {
    *this = ::std::move(from);
  }

  inline GaitReply& operator=(const GaitReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GaitReply& operator=(GaitReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GaitReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GaitReply* internal_default_instance() {
    return reinterpret_cast<const GaitReply*>(
               &_GaitReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GaitReply& a, GaitReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GaitReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GaitReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GaitReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GaitReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GaitReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GaitReply& from) {
    GaitReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GaitReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.GaitReply";
  }
  protected:
  explicit GaitReply(::google::protobuf::Arena* arena);
  GaitReply(::google::protobuf::Arena* arena, const GaitReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZetaFieldNumber = 7,
    kStanceheightFieldNumber = 8,
    kLiftheightFieldNumber = 9,
    kSteplengthFieldNumber = 10,
    kTypeFieldNumber = 6,
  };
  // double zeta = 7;
  void clear_zeta() ;
  double zeta() const;
  void set_zeta(double value);

  private:
  double _internal_zeta() const;
  void _internal_set_zeta(double value);

  public:
  // double stanceheight = 8;
  void clear_stanceheight() ;
  double stanceheight() const;
  void set_stanceheight(double value);

  private:
  double _internal_stanceheight() const;
  void _internal_set_stanceheight(double value);

  public:
  // double liftheight = 9;
  void clear_liftheight() ;
  double liftheight() const;
  void set_liftheight(double value);

  private:
  double _internal_liftheight() const;
  void _internal_set_liftheight(double value);

  public:
  // double steplength = 10;
  void clear_steplength() ;
  double steplength() const;
  void set_steplength(double value);

  private:
  double _internal_steplength() const;
  void _internal_set_steplength(double value);

  public:
  // .robot_msg.GAIT type = 6;
  void clear_type() ;
  ::robot_msg::GAIT type() const;
  void set_type(::robot_msg::GAIT value);

  private:
  ::robot_msg::GAIT _internal_type() const;
  void _internal_set_type(::robot_msg::GAIT value);

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.GaitReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double zeta_;
    double stanceheight_;
    double liftheight_;
    double steplength_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class FootPhase final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.FootPhase) */ {
 public:
  inline FootPhase() : FootPhase(nullptr) {}
  ~FootPhase() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FootPhase(::google::protobuf::internal::ConstantInitialized);

  inline FootPhase(const FootPhase& from)
      : FootPhase(nullptr, from) {}
  FootPhase(FootPhase&& from) noexcept
    : FootPhase() {
    *this = ::std::move(from);
  }

  inline FootPhase& operator=(const FootPhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootPhase& operator=(FootPhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FootPhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const FootPhase* internal_default_instance() {
    return reinterpret_cast<const FootPhase*>(
               &_FootPhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FootPhase& a, FootPhase& b) {
    a.Swap(&b);
  }
  inline void Swap(FootPhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootPhase* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FootPhase* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FootPhase>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FootPhase& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FootPhase& from) {
    FootPhase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FootPhase* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.FootPhase";
  }
  protected:
  explicit FootPhase(::google::protobuf::Arena* arena);
  FootPhase(::google::protobuf::Arena* arena, const FootPhase& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhaseFieldNumber = 1,
    kContactFieldNumber = 2,
    kZetaFieldNumber = 3,
  };
  // repeated double phase = 1;
  int phase_size() const;
  private:
  int _internal_phase_size() const;

  public:
  void clear_phase() ;
  double phase(int index) const;
  void set_phase(int index, double value);
  void add_phase(double value);
  const ::google::protobuf::RepeatedField<double>& phase() const;
  ::google::protobuf::RepeatedField<double>* mutable_phase();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_phase() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_phase();

  public:
  // repeated bool contact = 2;
  int contact_size() const;
  private:
  int _internal_contact_size() const;

  public:
  void clear_contact() ;
  bool contact(int index) const;
  void set_contact(int index, bool value);
  void add_contact(bool value);
  const ::google::protobuf::RepeatedField<bool>& contact() const;
  ::google::protobuf::RepeatedField<bool>* mutable_contact();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_contact() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_contact();

  public:
  // double zeta = 3;
  void clear_zeta() ;
  double zeta() const;
  void set_zeta(double value);

  private:
  double _internal_zeta() const;
  void _internal_set_zeta(double value);

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.FootPhase)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> phase_;
    ::google::protobuf::RepeatedField<bool> contact_;
    double zeta_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class State final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR State(::google::protobuf::internal::ConstantInitialized);

  inline State(const State& from)
      : State(nullptr, from) {}
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const State& from) {
    State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(State* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.State";
  }
  protected:
  explicit State(::google::protobuf::Arena* arena);
  State(::google::protobuf::Arena* arena, const State& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kTwistFieldNumber = 2,
  };
  // .geometry_msg.Pose pose = 1;
  bool has_pose() const;
  void clear_pose() ;
  const ::geometry_msg::Pose& pose() const;
  PROTOBUF_NODISCARD ::geometry_msg::Pose* release_pose();
  ::geometry_msg::Pose* mutable_pose();
  void set_allocated_pose(::geometry_msg::Pose* value);
  void unsafe_arena_set_allocated_pose(::geometry_msg::Pose* value);
  ::geometry_msg::Pose* unsafe_arena_release_pose();

  private:
  const ::geometry_msg::Pose& _internal_pose() const;
  ::geometry_msg::Pose* _internal_mutable_pose();

  public:
  // .geometry_msg.Twist twist = 2;
  bool has_twist() const;
  void clear_twist() ;
  const ::geometry_msg::Twist& twist() const;
  PROTOBUF_NODISCARD ::geometry_msg::Twist* release_twist();
  ::geometry_msg::Twist* mutable_twist();
  void set_allocated_twist(::geometry_msg::Twist* value);
  void unsafe_arena_set_allocated_twist(::geometry_msg::Twist* value);
  ::geometry_msg::Twist* unsafe_arena_release_twist();

  private:
  const ::geometry_msg::Twist& _internal_twist() const;
  ::geometry_msg::Twist* _internal_mutable_twist();

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.State)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::geometry_msg::Pose* pose_;
    ::geometry_msg::Twist* twist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class FootPrint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.FootPrint) */ {
 public:
  inline FootPrint() : FootPrint(nullptr) {}
  ~FootPrint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FootPrint(::google::protobuf::internal::ConstantInitialized);

  inline FootPrint(const FootPrint& from)
      : FootPrint(nullptr, from) {}
  FootPrint(FootPrint&& from) noexcept
    : FootPrint() {
    *this = ::std::move(from);
  }

  inline FootPrint& operator=(const FootPrint& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootPrint& operator=(FootPrint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FootPrint& default_instance() {
    return *internal_default_instance();
  }
  static inline const FootPrint* internal_default_instance() {
    return reinterpret_cast<const FootPrint*>(
               &_FootPrint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FootPrint& a, FootPrint& b) {
    a.Swap(&b);
  }
  inline void Swap(FootPrint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootPrint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FootPrint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FootPrint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FootPrint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FootPrint& from) {
    FootPrint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FootPrint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.FootPrint";
  }
  protected:
  explicit FootPrint(::google::protobuf::Arena* arena);
  FootPrint(::google::protobuf::Arena* arena, const FootPrint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // repeated .geometry_msg.Pose pose = 1;
  int pose_size() const;
  private:
  int _internal_pose_size() const;

  public:
  void clear_pose() ;
  ::geometry_msg::Pose* mutable_pose(int index);
  ::google::protobuf::RepeatedPtrField< ::geometry_msg::Pose >*
      mutable_pose();
  private:
  const ::google::protobuf::RepeatedPtrField<::geometry_msg::Pose>& _internal_pose() const;
  ::google::protobuf::RepeatedPtrField<::geometry_msg::Pose>* _internal_mutable_pose();
  public:
  const ::geometry_msg::Pose& pose(int index) const;
  ::geometry_msg::Pose* add_pose();
  const ::google::protobuf::RepeatedPtrField< ::geometry_msg::Pose >&
      pose() const;
  // @@protoc_insertion_point(class_scope:robot_msg.FootPrint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::geometry_msg::Pose > pose_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class StateWithCovariance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.StateWithCovariance) */ {
 public:
  inline StateWithCovariance() : StateWithCovariance(nullptr) {}
  ~StateWithCovariance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateWithCovariance(::google::protobuf::internal::ConstantInitialized);

  inline StateWithCovariance(const StateWithCovariance& from)
      : StateWithCovariance(nullptr, from) {}
  StateWithCovariance(StateWithCovariance&& from) noexcept
    : StateWithCovariance() {
    *this = ::std::move(from);
  }

  inline StateWithCovariance& operator=(const StateWithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateWithCovariance& operator=(StateWithCovariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateWithCovariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateWithCovariance* internal_default_instance() {
    return reinterpret_cast<const StateWithCovariance*>(
               &_StateWithCovariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StateWithCovariance& a, StateWithCovariance& b) {
    a.Swap(&b);
  }
  inline void Swap(StateWithCovariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateWithCovariance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateWithCovariance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateWithCovariance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateWithCovariance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StateWithCovariance& from) {
    StateWithCovariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StateWithCovariance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.StateWithCovariance";
  }
  protected:
  explicit StateWithCovariance(::google::protobuf::Arena* arena);
  StateWithCovariance(::google::protobuf::Arena* arena, const StateWithCovariance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kTwistFieldNumber = 2,
  };
  // .geometry_msg.PoseWithCovariance pose = 1;
  bool has_pose() const;
  void clear_pose() ;
  const ::geometry_msg::PoseWithCovariance& pose() const;
  PROTOBUF_NODISCARD ::geometry_msg::PoseWithCovariance* release_pose();
  ::geometry_msg::PoseWithCovariance* mutable_pose();
  void set_allocated_pose(::geometry_msg::PoseWithCovariance* value);
  void unsafe_arena_set_allocated_pose(::geometry_msg::PoseWithCovariance* value);
  ::geometry_msg::PoseWithCovariance* unsafe_arena_release_pose();

  private:
  const ::geometry_msg::PoseWithCovariance& _internal_pose() const;
  ::geometry_msg::PoseWithCovariance* _internal_mutable_pose();

  public:
  // .geometry_msg.TwistWithCovariance twist = 2;
  bool has_twist() const;
  void clear_twist() ;
  const ::geometry_msg::TwistWithCovariance& twist() const;
  PROTOBUF_NODISCARD ::geometry_msg::TwistWithCovariance* release_twist();
  ::geometry_msg::TwistWithCovariance* mutable_twist();
  void set_allocated_twist(::geometry_msg::TwistWithCovariance* value);
  void unsafe_arena_set_allocated_twist(::geometry_msg::TwistWithCovariance* value);
  ::geometry_msg::TwistWithCovariance* unsafe_arena_release_twist();

  private:
  const ::geometry_msg::TwistWithCovariance& _internal_twist() const;
  ::geometry_msg::TwistWithCovariance* _internal_mutable_twist();

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.StateWithCovariance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::geometry_msg::PoseWithCovariance* pose_;
    ::geometry_msg::TwistWithCovariance* twist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class StateStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.StateStamped) */ {
 public:
  inline StateStamped() : StateStamped(nullptr) {}
  ~StateStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateStamped(::google::protobuf::internal::ConstantInitialized);

  inline StateStamped(const StateStamped& from)
      : StateStamped(nullptr, from) {}
  StateStamped(StateStamped&& from) noexcept
    : StateStamped() {
    *this = ::std::move(from);
  }

  inline StateStamped& operator=(const StateStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateStamped& operator=(StateStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateStamped* internal_default_instance() {
    return reinterpret_cast<const StateStamped*>(
               &_StateStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StateStamped& a, StateStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(StateStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StateStamped& from) {
    StateStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StateStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.StateStamped";
  }
  protected:
  explicit StateStamped(::google::protobuf::Arena* arena);
  StateStamped(::google::protobuf::Arena* arena, const StateStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .robot_msg.State state = 2;
  bool has_state() const;
  void clear_state() ;
  const ::robot_msg::State& state() const;
  PROTOBUF_NODISCARD ::robot_msg::State* release_state();
  ::robot_msg::State* mutable_state();
  void set_allocated_state(::robot_msg::State* value);
  void unsafe_arena_set_allocated_state(::robot_msg::State* value);
  ::robot_msg::State* unsafe_arena_release_state();

  private:
  const ::robot_msg::State& _internal_state() const;
  ::robot_msg::State* _internal_mutable_state();

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.StateStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::robot_msg::State* state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class GaitInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.GaitInfo) */ {
 public:
  inline GaitInfo() : GaitInfo(nullptr) {}
  ~GaitInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GaitInfo(::google::protobuf::internal::ConstantInitialized);

  inline GaitInfo(const GaitInfo& from)
      : GaitInfo(nullptr, from) {}
  GaitInfo(GaitInfo&& from) noexcept
    : GaitInfo() {
    *this = ::std::move(from);
  }

  inline GaitInfo& operator=(const GaitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GaitInfo& operator=(GaitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GaitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GaitInfo* internal_default_instance() {
    return reinterpret_cast<const GaitInfo*>(
               &_GaitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GaitInfo& a, GaitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GaitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GaitInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GaitInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GaitInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GaitInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GaitInfo& from) {
    GaitInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GaitInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.GaitInfo";
  }
  protected:
  explicit GaitInfo(::google::protobuf::Arena* arena);
  GaitInfo(::google::protobuf::Arena* arena, const GaitInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPhaseFieldNumber = 3,
    kPositionFieldNumber = 4,
    kCentroidFieldNumber = 5,
    kTypeFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .robot_msg.FootPhase phase = 3;
  bool has_phase() const;
  void clear_phase() ;
  const ::robot_msg::FootPhase& phase() const;
  PROTOBUF_NODISCARD ::robot_msg::FootPhase* release_phase();
  ::robot_msg::FootPhase* mutable_phase();
  void set_allocated_phase(::robot_msg::FootPhase* value);
  void unsafe_arena_set_allocated_phase(::robot_msg::FootPhase* value);
  ::robot_msg::FootPhase* unsafe_arena_release_phase();

  private:
  const ::robot_msg::FootPhase& _internal_phase() const;
  ::robot_msg::FootPhase* _internal_mutable_phase();

  public:
  // .robot_msg.FootPrint position = 4;
  bool has_position() const;
  void clear_position() ;
  const ::robot_msg::FootPrint& position() const;
  PROTOBUF_NODISCARD ::robot_msg::FootPrint* release_position();
  ::robot_msg::FootPrint* mutable_position();
  void set_allocated_position(::robot_msg::FootPrint* value);
  void unsafe_arena_set_allocated_position(::robot_msg::FootPrint* value);
  ::robot_msg::FootPrint* unsafe_arena_release_position();

  private:
  const ::robot_msg::FootPrint& _internal_position() const;
  ::robot_msg::FootPrint* _internal_mutable_position();

  public:
  // .geometry_msg.Pose centroid = 5;
  bool has_centroid() const;
  void clear_centroid() ;
  const ::geometry_msg::Pose& centroid() const;
  PROTOBUF_NODISCARD ::geometry_msg::Pose* release_centroid();
  ::geometry_msg::Pose* mutable_centroid();
  void set_allocated_centroid(::geometry_msg::Pose* value);
  void unsafe_arena_set_allocated_centroid(::geometry_msg::Pose* value);
  ::geometry_msg::Pose* unsafe_arena_release_centroid();

  private:
  const ::geometry_msg::Pose& _internal_centroid() const;
  ::geometry_msg::Pose* _internal_mutable_centroid();

  public:
  // .robot_msg.GAIT type = 2;
  void clear_type() ;
  ::robot_msg::GAIT type() const;
  void set_type(::robot_msg::GAIT value);

  private:
  ::robot_msg::GAIT _internal_type() const;
  void _internal_set_type(::robot_msg::GAIT value);

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.GaitInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::robot_msg::FootPhase* phase_;
    ::robot_msg::FootPrint* position_;
    ::geometry_msg::Pose* centroid_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};// -------------------------------------------------------------------

class StateStampedWithCovariance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_msg.StateStampedWithCovariance) */ {
 public:
  inline StateStampedWithCovariance() : StateStampedWithCovariance(nullptr) {}
  ~StateStampedWithCovariance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateStampedWithCovariance(::google::protobuf::internal::ConstantInitialized);

  inline StateStampedWithCovariance(const StateStampedWithCovariance& from)
      : StateStampedWithCovariance(nullptr, from) {}
  StateStampedWithCovariance(StateStampedWithCovariance&& from) noexcept
    : StateStampedWithCovariance() {
    *this = ::std::move(from);
  }

  inline StateStampedWithCovariance& operator=(const StateStampedWithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateStampedWithCovariance& operator=(StateStampedWithCovariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateStampedWithCovariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateStampedWithCovariance* internal_default_instance() {
    return reinterpret_cast<const StateStampedWithCovariance*>(
               &_StateStampedWithCovariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StateStampedWithCovariance& a, StateStampedWithCovariance& b) {
    a.Swap(&b);
  }
  inline void Swap(StateStampedWithCovariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateStampedWithCovariance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateStampedWithCovariance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateStampedWithCovariance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateStampedWithCovariance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StateStampedWithCovariance& from) {
    StateStampedWithCovariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StateStampedWithCovariance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "robot_msg.StateStampedWithCovariance";
  }
  protected:
  explicit StateStampedWithCovariance(::google::protobuf::Arena* arena);
  StateStampedWithCovariance(::google::protobuf::Arena* arena, const StateStampedWithCovariance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .robot_msg.StateWithCovariance state = 2;
  bool has_state() const;
  void clear_state() ;
  const ::robot_msg::StateWithCovariance& state() const;
  PROTOBUF_NODISCARD ::robot_msg::StateWithCovariance* release_state();
  ::robot_msg::StateWithCovariance* mutable_state();
  void set_allocated_state(::robot_msg::StateWithCovariance* value);
  void unsafe_arena_set_allocated_state(::robot_msg::StateWithCovariance* value);
  ::robot_msg::StateWithCovariance* unsafe_arena_release_state();

  private:
  const ::robot_msg::StateWithCovariance& _internal_state() const;
  ::robot_msg::StateWithCovariance* _internal_mutable_state();

  public:
  // @@protoc_insertion_point(class_scope:robot_msg.StateStampedWithCovariance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::robot_msg::StateWithCovariance* state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FootPrint

// repeated .geometry_msg.Pose pose = 1;
inline int FootPrint::_internal_pose_size() const {
  return _internal_pose().size();
}
inline int FootPrint::pose_size() const {
  return _internal_pose_size();
}
inline ::geometry_msg::Pose* FootPrint::mutable_pose(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:robot_msg.FootPrint.pose)
  return _internal_mutable_pose()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::geometry_msg::Pose>* FootPrint::mutable_pose()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:robot_msg.FootPrint.pose)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_pose();
}
inline const ::geometry_msg::Pose& FootPrint::pose(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.FootPrint.pose)
  return _internal_pose().Get(index);
}
inline ::geometry_msg::Pose* FootPrint::add_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::geometry_msg::Pose* _add = _internal_mutable_pose()->Add();
  // @@protoc_insertion_point(field_add:robot_msg.FootPrint.pose)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::geometry_msg::Pose>& FootPrint::pose() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:robot_msg.FootPrint.pose)
  return _internal_pose();
}
inline const ::google::protobuf::RepeatedPtrField<::geometry_msg::Pose>&
FootPrint::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pose_;
}
inline ::google::protobuf::RepeatedPtrField<::geometry_msg::Pose>*
FootPrint::_internal_mutable_pose() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.pose_;
}

// -------------------------------------------------------------------

// FootPhase

// repeated double phase = 1;
inline int FootPhase::_internal_phase_size() const {
  return _internal_phase().size();
}
inline int FootPhase::phase_size() const {
  return _internal_phase_size();
}
inline void FootPhase::clear_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phase_.Clear();
}
inline double FootPhase::phase(int index) const {
  // @@protoc_insertion_point(field_get:robot_msg.FootPhase.phase)
  return _internal_phase().Get(index);
}
inline void FootPhase::set_phase(int index, double value) {
  _internal_mutable_phase()->Set(index, value);
  // @@protoc_insertion_point(field_set:robot_msg.FootPhase.phase)
}
inline void FootPhase::add_phase(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_phase()->Add(value);
  // @@protoc_insertion_point(field_add:robot_msg.FootPhase.phase)
}
inline const ::google::protobuf::RepeatedField<double>& FootPhase::phase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:robot_msg.FootPhase.phase)
  return _internal_phase();
}
inline ::google::protobuf::RepeatedField<double>* FootPhase::mutable_phase()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:robot_msg.FootPhase.phase)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_phase();
}
inline const ::google::protobuf::RepeatedField<double>& FootPhase::_internal_phase()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phase_;
}
inline ::google::protobuf::RepeatedField<double>* FootPhase::_internal_mutable_phase() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.phase_;
}

// repeated bool contact = 2;
inline int FootPhase::_internal_contact_size() const {
  return _internal_contact().size();
}
inline int FootPhase::contact_size() const {
  return _internal_contact_size();
}
inline void FootPhase::clear_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contact_.Clear();
}
inline bool FootPhase::contact(int index) const {
  // @@protoc_insertion_point(field_get:robot_msg.FootPhase.contact)
  return _internal_contact().Get(index);
}
inline void FootPhase::set_contact(int index, bool value) {
  _internal_mutable_contact()->Set(index, value);
  // @@protoc_insertion_point(field_set:robot_msg.FootPhase.contact)
}
inline void FootPhase::add_contact(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_contact()->Add(value);
  // @@protoc_insertion_point(field_add:robot_msg.FootPhase.contact)
}
inline const ::google::protobuf::RepeatedField<bool>& FootPhase::contact() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:robot_msg.FootPhase.contact)
  return _internal_contact();
}
inline ::google::protobuf::RepeatedField<bool>* FootPhase::mutable_contact()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:robot_msg.FootPhase.contact)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_contact();
}
inline const ::google::protobuf::RepeatedField<bool>& FootPhase::_internal_contact()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contact_;
}
inline ::google::protobuf::RepeatedField<bool>* FootPhase::_internal_mutable_contact() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.contact_;
}

// double zeta = 3;
inline void FootPhase::clear_zeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zeta_ = 0;
}
inline double FootPhase::zeta() const {
  // @@protoc_insertion_point(field_get:robot_msg.FootPhase.zeta)
  return _internal_zeta();
}
inline void FootPhase::set_zeta(double value) {
  _internal_set_zeta(value);
  // @@protoc_insertion_point(field_set:robot_msg.FootPhase.zeta)
}
inline double FootPhase::_internal_zeta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zeta_;
}
inline void FootPhase::_internal_set_zeta(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zeta_ = value;
}

// -------------------------------------------------------------------

// GaitInfo

// .std_msg.Header header = 1;
inline bool GaitInfo::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& GaitInfo::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& GaitInfo::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.GaitInfo.header)
  return _internal_header();
}
inline void GaitInfo::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.GaitInfo.header)
}
inline ::std_msg::Header* GaitInfo::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* GaitInfo::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.GaitInfo.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* GaitInfo::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* GaitInfo::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:robot_msg.GaitInfo.header)
  return _msg;
}
inline void GaitInfo::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.GaitInfo.header)
}

// .robot_msg.GAIT type = 2;
inline void GaitInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::robot_msg::GAIT GaitInfo::type() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitInfo.type)
  return _internal_type();
}
inline void GaitInfo::set_type(::robot_msg::GAIT value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitInfo.type)
}
inline ::robot_msg::GAIT GaitInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::robot_msg::GAIT>(_impl_.type_);
}
inline void GaitInfo::_internal_set_type(::robot_msg::GAIT value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .robot_msg.FootPhase phase = 3;
inline bool GaitInfo::has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.phase_ != nullptr);
  return value;
}
inline void GaitInfo::clear_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.phase_ != nullptr) _impl_.phase_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::robot_msg::FootPhase& GaitInfo::_internal_phase() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::robot_msg::FootPhase* p = _impl_.phase_;
  return p != nullptr ? *p : reinterpret_cast<const ::robot_msg::FootPhase&>(::robot_msg::_FootPhase_default_instance_);
}
inline const ::robot_msg::FootPhase& GaitInfo::phase() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.GaitInfo.phase)
  return _internal_phase();
}
inline void GaitInfo::unsafe_arena_set_allocated_phase(::robot_msg::FootPhase* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.phase_);
  }
  _impl_.phase_ = reinterpret_cast<::robot_msg::FootPhase*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.GaitInfo.phase)
}
inline ::robot_msg::FootPhase* GaitInfo::release_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::robot_msg::FootPhase* released = _impl_.phase_;
  _impl_.phase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::robot_msg::FootPhase* GaitInfo::unsafe_arena_release_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.GaitInfo.phase)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::robot_msg::FootPhase* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
  return temp;
}
inline ::robot_msg::FootPhase* GaitInfo::_internal_mutable_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot_msg::FootPhase>(GetArena());
    _impl_.phase_ = reinterpret_cast<::robot_msg::FootPhase*>(p);
  }
  return _impl_.phase_;
}
inline ::robot_msg::FootPhase* GaitInfo::mutable_phase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robot_msg::FootPhase* _msg = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:robot_msg.GaitInfo.phase)
  return _msg;
}
inline void GaitInfo::set_allocated_phase(::robot_msg::FootPhase* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::robot_msg::FootPhase*>(_impl_.phase_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::robot_msg::FootPhase*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.phase_ = reinterpret_cast<::robot_msg::FootPhase*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.GaitInfo.phase)
}

// .robot_msg.FootPrint position = 4;
inline bool GaitInfo::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void GaitInfo::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::robot_msg::FootPrint& GaitInfo::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::robot_msg::FootPrint* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::robot_msg::FootPrint&>(::robot_msg::_FootPrint_default_instance_);
}
inline const ::robot_msg::FootPrint& GaitInfo::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.GaitInfo.position)
  return _internal_position();
}
inline void GaitInfo::unsafe_arena_set_allocated_position(::robot_msg::FootPrint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::robot_msg::FootPrint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.GaitInfo.position)
}
inline ::robot_msg::FootPrint* GaitInfo::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::robot_msg::FootPrint* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::robot_msg::FootPrint* GaitInfo::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.GaitInfo.position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::robot_msg::FootPrint* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::robot_msg::FootPrint* GaitInfo::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot_msg::FootPrint>(GetArena());
    _impl_.position_ = reinterpret_cast<::robot_msg::FootPrint*>(p);
  }
  return _impl_.position_;
}
inline ::robot_msg::FootPrint* GaitInfo::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robot_msg::FootPrint* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:robot_msg.GaitInfo.position)
  return _msg;
}
inline void GaitInfo::set_allocated_position(::robot_msg::FootPrint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::robot_msg::FootPrint*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::robot_msg::FootPrint*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_ = reinterpret_cast<::robot_msg::FootPrint*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.GaitInfo.position)
}

// .geometry_msg.Pose centroid = 5;
inline bool GaitInfo::has_centroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.centroid_ != nullptr);
  return value;
}
inline const ::geometry_msg::Pose& GaitInfo::_internal_centroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Pose* p = _impl_.centroid_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Pose&>(::geometry_msg::_Pose_default_instance_);
}
inline const ::geometry_msg::Pose& GaitInfo::centroid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.GaitInfo.centroid)
  return _internal_centroid();
}
inline void GaitInfo::unsafe_arena_set_allocated_centroid(::geometry_msg::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.centroid_);
  }
  _impl_.centroid_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.GaitInfo.centroid)
}
inline ::geometry_msg::Pose* GaitInfo::release_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::geometry_msg::Pose* released = _impl_.centroid_;
  _impl_.centroid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Pose* GaitInfo::unsafe_arena_release_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.GaitInfo.centroid)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::geometry_msg::Pose* temp = _impl_.centroid_;
  _impl_.centroid_ = nullptr;
  return temp;
}
inline ::geometry_msg::Pose* GaitInfo::_internal_mutable_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.centroid_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Pose>(GetArena());
    _impl_.centroid_ = reinterpret_cast<::geometry_msg::Pose*>(p);
  }
  return _impl_.centroid_;
}
inline ::geometry_msg::Pose* GaitInfo::mutable_centroid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Pose* _msg = _internal_mutable_centroid();
  // @@protoc_insertion_point(field_mutable:robot_msg.GaitInfo.centroid)
  return _msg;
}
inline void GaitInfo::set_allocated_centroid(::geometry_msg::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.centroid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.centroid_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.GaitInfo.centroid)
}

// -------------------------------------------------------------------

// GaitRequest

// .robot_msg.GAIT type = 1;
inline void GaitRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::robot_msg::GAIT GaitRequest::type() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitRequest.type)
  return _internal_type();
}
inline void GaitRequest::set_type(::robot_msg::GAIT value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitRequest.type)
}
inline ::robot_msg::GAIT GaitRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::robot_msg::GAIT>(_impl_.type_);
}
inline void GaitRequest::_internal_set_type(::robot_msg::GAIT value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// double zeta = 2;
inline void GaitRequest::clear_zeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zeta_ = 0;
}
inline double GaitRequest::zeta() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitRequest.zeta)
  return _internal_zeta();
}
inline void GaitRequest::set_zeta(double value) {
  _internal_set_zeta(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitRequest.zeta)
}
inline double GaitRequest::_internal_zeta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zeta_;
}
inline void GaitRequest::_internal_set_zeta(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zeta_ = value;
}

// double stanceheight = 3;
inline void GaitRequest::clear_stanceheight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stanceheight_ = 0;
}
inline double GaitRequest::stanceheight() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitRequest.stanceheight)
  return _internal_stanceheight();
}
inline void GaitRequest::set_stanceheight(double value) {
  _internal_set_stanceheight(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitRequest.stanceheight)
}
inline double GaitRequest::_internal_stanceheight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stanceheight_;
}
inline void GaitRequest::_internal_set_stanceheight(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stanceheight_ = value;
}

// double liftheight = 4;
inline void GaitRequest::clear_liftheight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.liftheight_ = 0;
}
inline double GaitRequest::liftheight() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitRequest.liftheight)
  return _internal_liftheight();
}
inline void GaitRequest::set_liftheight(double value) {
  _internal_set_liftheight(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitRequest.liftheight)
}
inline double GaitRequest::_internal_liftheight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.liftheight_;
}
inline void GaitRequest::_internal_set_liftheight(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.liftheight_ = value;
}

// double steplength = 5;
inline void GaitRequest::clear_steplength() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steplength_ = 0;
}
inline double GaitRequest::steplength() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitRequest.steplength)
  return _internal_steplength();
}
inline void GaitRequest::set_steplength(double value) {
  _internal_set_steplength(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitRequest.steplength)
}
inline double GaitRequest::_internal_steplength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steplength_;
}
inline void GaitRequest::_internal_set_steplength(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.steplength_ = value;
}

// -------------------------------------------------------------------

// GaitReply

// .robot_msg.GAIT type = 6;
inline void GaitReply::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::robot_msg::GAIT GaitReply::type() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitReply.type)
  return _internal_type();
}
inline void GaitReply::set_type(::robot_msg::GAIT value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitReply.type)
}
inline ::robot_msg::GAIT GaitReply::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::robot_msg::GAIT>(_impl_.type_);
}
inline void GaitReply::_internal_set_type(::robot_msg::GAIT value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// double zeta = 7;
inline void GaitReply::clear_zeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zeta_ = 0;
}
inline double GaitReply::zeta() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitReply.zeta)
  return _internal_zeta();
}
inline void GaitReply::set_zeta(double value) {
  _internal_set_zeta(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitReply.zeta)
}
inline double GaitReply::_internal_zeta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zeta_;
}
inline void GaitReply::_internal_set_zeta(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zeta_ = value;
}

// double stanceheight = 8;
inline void GaitReply::clear_stanceheight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stanceheight_ = 0;
}
inline double GaitReply::stanceheight() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitReply.stanceheight)
  return _internal_stanceheight();
}
inline void GaitReply::set_stanceheight(double value) {
  _internal_set_stanceheight(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitReply.stanceheight)
}
inline double GaitReply::_internal_stanceheight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stanceheight_;
}
inline void GaitReply::_internal_set_stanceheight(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stanceheight_ = value;
}

// double liftheight = 9;
inline void GaitReply::clear_liftheight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.liftheight_ = 0;
}
inline double GaitReply::liftheight() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitReply.liftheight)
  return _internal_liftheight();
}
inline void GaitReply::set_liftheight(double value) {
  _internal_set_liftheight(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitReply.liftheight)
}
inline double GaitReply::_internal_liftheight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.liftheight_;
}
inline void GaitReply::_internal_set_liftheight(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.liftheight_ = value;
}

// double steplength = 10;
inline void GaitReply::clear_steplength() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steplength_ = 0;
}
inline double GaitReply::steplength() const {
  // @@protoc_insertion_point(field_get:robot_msg.GaitReply.steplength)
  return _internal_steplength();
}
inline void GaitReply::set_steplength(double value) {
  _internal_set_steplength(value);
  // @@protoc_insertion_point(field_set:robot_msg.GaitReply.steplength)
}
inline double GaitReply::_internal_steplength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steplength_;
}
inline void GaitReply::_internal_set_steplength(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.steplength_ = value;
}

// -------------------------------------------------------------------

// State

// .geometry_msg.Pose pose = 1;
inline bool State::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline const ::geometry_msg::Pose& State::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Pose&>(::geometry_msg::_Pose_default_instance_);
}
inline const ::geometry_msg::Pose& State::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.State.pose)
  return _internal_pose();
}
inline void State::unsafe_arena_set_allocated_pose(::geometry_msg::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.State.pose)
}
inline ::geometry_msg::Pose* State::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Pose* State::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.State.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::geometry_msg::Pose* State::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::geometry_msg::Pose* State::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:robot_msg.State.pose)
  return _msg;
}
inline void State::set_allocated_pose(::geometry_msg::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.State.pose)
}

// .geometry_msg.Twist twist = 2;
inline bool State::has_twist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.twist_ != nullptr);
  return value;
}
inline const ::geometry_msg::Twist& State::_internal_twist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Twist* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Twist&>(::geometry_msg::_Twist_default_instance_);
}
inline const ::geometry_msg::Twist& State::twist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.State.twist)
  return _internal_twist();
}
inline void State::unsafe_arena_set_allocated_twist(::geometry_msg::Twist* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.State.twist)
}
inline ::geometry_msg::Twist* State::release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Twist* released = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Twist* State::unsafe_arena_release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.State.twist)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::geometry_msg::Twist* State::_internal_mutable_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Twist>(GetArena());
    _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(p);
  }
  return _impl_.twist_;
}
inline ::geometry_msg::Twist* State::mutable_twist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Twist* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:robot_msg.State.twist)
  return _msg;
}
inline void State::set_allocated_twist(::geometry_msg::Twist* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.State.twist)
}

// -------------------------------------------------------------------

// StateStamped

// .std_msg.Header header = 1;
inline bool StateStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& StateStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& StateStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.StateStamped.header)
  return _internal_header();
}
inline void StateStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.StateStamped.header)
}
inline ::std_msg::Header* StateStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* StateStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.StateStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* StateStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* StateStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:robot_msg.StateStamped.header)
  return _msg;
}
inline void StateStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.StateStamped.header)
}

// .robot_msg.State state = 2;
inline bool StateStamped::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void StateStamped::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::robot_msg::State& StateStamped::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::robot_msg::State* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::robot_msg::State&>(::robot_msg::_State_default_instance_);
}
inline const ::robot_msg::State& StateStamped::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.StateStamped.state)
  return _internal_state();
}
inline void StateStamped::unsafe_arena_set_allocated_state(::robot_msg::State* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::robot_msg::State*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.StateStamped.state)
}
inline ::robot_msg::State* StateStamped::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::robot_msg::State* released = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::robot_msg::State* StateStamped::unsafe_arena_release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.StateStamped.state)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::robot_msg::State* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::robot_msg::State* StateStamped::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot_msg::State>(GetArena());
    _impl_.state_ = reinterpret_cast<::robot_msg::State*>(p);
  }
  return _impl_.state_;
}
inline ::robot_msg::State* StateStamped::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robot_msg::State* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:robot_msg.StateStamped.state)
  return _msg;
}
inline void StateStamped::set_allocated_state(::robot_msg::State* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::robot_msg::State*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::robot_msg::State*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.state_ = reinterpret_cast<::robot_msg::State*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.StateStamped.state)
}

// -------------------------------------------------------------------

// StateWithCovariance

// .geometry_msg.PoseWithCovariance pose = 1;
inline bool StateWithCovariance::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline const ::geometry_msg::PoseWithCovariance& StateWithCovariance::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::PoseWithCovariance* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::PoseWithCovariance&>(::geometry_msg::_PoseWithCovariance_default_instance_);
}
inline const ::geometry_msg::PoseWithCovariance& StateWithCovariance::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.StateWithCovariance.pose)
  return _internal_pose();
}
inline void StateWithCovariance::unsafe_arena_set_allocated_pose(::geometry_msg::PoseWithCovariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.StateWithCovariance.pose)
}
inline ::geometry_msg::PoseWithCovariance* StateWithCovariance::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::PoseWithCovariance* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::PoseWithCovariance* StateWithCovariance::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.StateWithCovariance.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::PoseWithCovariance* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::geometry_msg::PoseWithCovariance* StateWithCovariance::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::PoseWithCovariance>(GetArena());
    _impl_.pose_ = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(p);
  }
  return _impl_.pose_;
}
inline ::geometry_msg::PoseWithCovariance* StateWithCovariance::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::PoseWithCovariance* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:robot_msg.StateWithCovariance.pose)
  return _msg;
}
inline void StateWithCovariance::set_allocated_pose(::geometry_msg::PoseWithCovariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.StateWithCovariance.pose)
}

// .geometry_msg.TwistWithCovariance twist = 2;
inline bool StateWithCovariance::has_twist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.twist_ != nullptr);
  return value;
}
inline const ::geometry_msg::TwistWithCovariance& StateWithCovariance::_internal_twist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::TwistWithCovariance* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::TwistWithCovariance&>(::geometry_msg::_TwistWithCovariance_default_instance_);
}
inline const ::geometry_msg::TwistWithCovariance& StateWithCovariance::twist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.StateWithCovariance.twist)
  return _internal_twist();
}
inline void StateWithCovariance::unsafe_arena_set_allocated_twist(::geometry_msg::TwistWithCovariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.StateWithCovariance.twist)
}
inline ::geometry_msg::TwistWithCovariance* StateWithCovariance::release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::TwistWithCovariance* released = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::TwistWithCovariance* StateWithCovariance::unsafe_arena_release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.StateWithCovariance.twist)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::TwistWithCovariance* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::geometry_msg::TwistWithCovariance* StateWithCovariance::_internal_mutable_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::TwistWithCovariance>(GetArena());
    _impl_.twist_ = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(p);
  }
  return _impl_.twist_;
}
inline ::geometry_msg::TwistWithCovariance* StateWithCovariance::mutable_twist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::TwistWithCovariance* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:robot_msg.StateWithCovariance.twist)
  return _msg;
}
inline void StateWithCovariance::set_allocated_twist(::geometry_msg::TwistWithCovariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.twist_ = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.StateWithCovariance.twist)
}

// -------------------------------------------------------------------

// StateStampedWithCovariance

// .std_msg.Header header = 1;
inline bool StateStampedWithCovariance::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& StateStampedWithCovariance::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& StateStampedWithCovariance::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.StateStampedWithCovariance.header)
  return _internal_header();
}
inline void StateStampedWithCovariance::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.StateStampedWithCovariance.header)
}
inline ::std_msg::Header* StateStampedWithCovariance::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* StateStampedWithCovariance::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.StateStampedWithCovariance.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* StateStampedWithCovariance::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* StateStampedWithCovariance::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:robot_msg.StateStampedWithCovariance.header)
  return _msg;
}
inline void StateStampedWithCovariance::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.StateStampedWithCovariance.header)
}

// .robot_msg.StateWithCovariance state = 2;
inline bool StateStampedWithCovariance::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void StateStampedWithCovariance::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::robot_msg::StateWithCovariance& StateStampedWithCovariance::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::robot_msg::StateWithCovariance* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::robot_msg::StateWithCovariance&>(::robot_msg::_StateWithCovariance_default_instance_);
}
inline const ::robot_msg::StateWithCovariance& StateStampedWithCovariance::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robot_msg.StateStampedWithCovariance.state)
  return _internal_state();
}
inline void StateStampedWithCovariance::unsafe_arena_set_allocated_state(::robot_msg::StateWithCovariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::robot_msg::StateWithCovariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot_msg.StateStampedWithCovariance.state)
}
inline ::robot_msg::StateWithCovariance* StateStampedWithCovariance::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::robot_msg::StateWithCovariance* released = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::robot_msg::StateWithCovariance* StateStampedWithCovariance::unsafe_arena_release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:robot_msg.StateStampedWithCovariance.state)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::robot_msg::StateWithCovariance* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::robot_msg::StateWithCovariance* StateStampedWithCovariance::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot_msg::StateWithCovariance>(GetArena());
    _impl_.state_ = reinterpret_cast<::robot_msg::StateWithCovariance*>(p);
  }
  return _impl_.state_;
}
inline ::robot_msg::StateWithCovariance* StateStampedWithCovariance::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robot_msg::StateWithCovariance* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:robot_msg.StateStampedWithCovariance.state)
  return _msg;
}
inline void StateStampedWithCovariance::set_allocated_state(::robot_msg::StateWithCovariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::robot_msg::StateWithCovariance*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::robot_msg::StateWithCovariance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.state_ = reinterpret_cast<::robot_msg::StateWithCovariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:robot_msg.StateStampedWithCovariance.state)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace robot_msg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::robot_msg::GAIT> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::robot_msg::GAIT>() {
  return ::robot_msg::GAIT_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_robot_2eproto_2epb_2eh
