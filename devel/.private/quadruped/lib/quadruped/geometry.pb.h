// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "std.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_geometry_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_geometry_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_geometry_2eproto;
namespace geometry_msg {
class Accel;
struct AccelDefaultTypeInternal;
extern AccelDefaultTypeInternal _Accel_default_instance_;
class AccelStamped;
struct AccelStampedDefaultTypeInternal;
extern AccelStampedDefaultTypeInternal _AccelStamped_default_instance_;
class AccelWithCovariance;
struct AccelWithCovarianceDefaultTypeInternal;
extern AccelWithCovarianceDefaultTypeInternal _AccelWithCovariance_default_instance_;
class AccelWithCovarianceStamped;
struct AccelWithCovarianceStampedDefaultTypeInternal;
extern AccelWithCovarianceStampedDefaultTypeInternal _AccelWithCovarianceStamped_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseStamped;
struct PoseStampedDefaultTypeInternal;
extern PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
class PoseWithCovariance;
struct PoseWithCovarianceDefaultTypeInternal;
extern PoseWithCovarianceDefaultTypeInternal _PoseWithCovariance_default_instance_;
class PoseWithCovarianceStamped;
struct PoseWithCovarianceStampedDefaultTypeInternal;
extern PoseWithCovarianceStampedDefaultTypeInternal _PoseWithCovarianceStamped_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class TransformStamped;
struct TransformStampedDefaultTypeInternal;
extern TransformStampedDefaultTypeInternal _TransformStamped_default_instance_;
class Twist;
struct TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class TwistStamped;
struct TwistStampedDefaultTypeInternal;
extern TwistStampedDefaultTypeInternal _TwistStamped_default_instance_;
class TwistWithCovariance;
struct TwistWithCovarianceDefaultTypeInternal;
extern TwistWithCovarianceDefaultTypeInternal _TwistWithCovariance_default_instance_;
class TwistWithCovarianceStamped;
struct TwistWithCovarianceStampedDefaultTypeInternal;
extern TwistWithCovarianceStampedDefaultTypeInternal _TwistWithCovarianceStamped_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace geometry_msg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace geometry_msg {

// ===================================================================


// -------------------------------------------------------------------

class Vector3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(::google::protobuf::internal::ConstantInitialized);

  inline Vector3(const Vector3& from)
      : Vector3(nullptr, from) {}
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.Vector3";
  }
  protected:
  explicit Vector3(::google::protobuf::Arena* arena);
  Vector3(::google::protobuf::Arena* arena, const Vector3& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.Vector3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline Quaternion(const Quaternion& from)
      : Quaternion(nullptr, from) {}
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Quaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.Quaternion";
  }
  protected:
  explicit Quaternion(::google::protobuf::Arena* arena);
  Quaternion(::google::protobuf::Arena* arena, const Quaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // double w = 4;
  void clear_w() ;
  double w() const;
  void set_w(double value);

  private:
  double _internal_w() const;
  void _internal_set_w(double value);

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.Quaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    double w_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class Twist final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.Twist) */ {
 public:
  inline Twist() : Twist(nullptr) {}
  ~Twist() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Twist(::google::protobuf::internal::ConstantInitialized);

  inline Twist(const Twist& from)
      : Twist(nullptr, from) {}
  Twist(Twist&& from) noexcept
    : Twist() {
    *this = ::std::move(from);
  }

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twist& operator=(Twist&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twist& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twist* internal_default_instance() {
    return reinterpret_cast<const Twist*>(
               &_Twist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Twist& a, Twist& b) {
    a.Swap(&b);
  }
  inline void Swap(Twist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twist* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twist* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twist>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Twist& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Twist& from) {
    Twist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Twist* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.Twist";
  }
  protected:
  explicit Twist(::google::protobuf::Arena* arena);
  Twist(::google::protobuf::Arena* arena, const Twist& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .geometry_msg.Vector3 linear = 1;
  bool has_linear() const;
  void clear_linear() ;
  const ::geometry_msg::Vector3& linear() const;
  PROTOBUF_NODISCARD ::geometry_msg::Vector3* release_linear();
  ::geometry_msg::Vector3* mutable_linear();
  void set_allocated_linear(::geometry_msg::Vector3* value);
  void unsafe_arena_set_allocated_linear(::geometry_msg::Vector3* value);
  ::geometry_msg::Vector3* unsafe_arena_release_linear();

  private:
  const ::geometry_msg::Vector3& _internal_linear() const;
  ::geometry_msg::Vector3* _internal_mutable_linear();

  public:
  // .geometry_msg.Vector3 angular = 2;
  bool has_angular() const;
  void clear_angular() ;
  const ::geometry_msg::Vector3& angular() const;
  PROTOBUF_NODISCARD ::geometry_msg::Vector3* release_angular();
  ::geometry_msg::Vector3* mutable_angular();
  void set_allocated_angular(::geometry_msg::Vector3* value);
  void unsafe_arena_set_allocated_angular(::geometry_msg::Vector3* value);
  ::geometry_msg::Vector3* unsafe_arena_release_angular();

  private:
  const ::geometry_msg::Vector3& _internal_angular() const;
  ::geometry_msg::Vector3* _internal_mutable_angular();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.Twist)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::geometry_msg::Vector3* linear_;
    ::geometry_msg::Vector3* angular_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class Transform final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transform(::google::protobuf::internal::ConstantInitialized);

  inline Transform(const Transform& from)
      : Transform(nullptr, from) {}
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transform* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Transform& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Transform& from) {
    Transform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Transform* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.Transform";
  }
  protected:
  explicit Transform(::google::protobuf::Arena* arena);
  Transform(::google::protobuf::Arena* arena, const Transform& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .geometry_msg.Vector3 translation = 1;
  bool has_translation() const;
  void clear_translation() ;
  const ::geometry_msg::Vector3& translation() const;
  PROTOBUF_NODISCARD ::geometry_msg::Vector3* release_translation();
  ::geometry_msg::Vector3* mutable_translation();
  void set_allocated_translation(::geometry_msg::Vector3* value);
  void unsafe_arena_set_allocated_translation(::geometry_msg::Vector3* value);
  ::geometry_msg::Vector3* unsafe_arena_release_translation();

  private:
  const ::geometry_msg::Vector3& _internal_translation() const;
  ::geometry_msg::Vector3* _internal_mutable_translation();

  public:
  // .geometry_msg.Quaternion rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::geometry_msg::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::geometry_msg::Quaternion* release_rotation();
  ::geometry_msg::Quaternion* mutable_rotation();
  void set_allocated_rotation(::geometry_msg::Quaternion* value);
  void unsafe_arena_set_allocated_rotation(::geometry_msg::Quaternion* value);
  ::geometry_msg::Quaternion* unsafe_arena_release_rotation();

  private:
  const ::geometry_msg::Quaternion& _internal_rotation() const;
  ::geometry_msg::Quaternion* _internal_mutable_rotation();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.Transform)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::geometry_msg::Vector3* translation_;
    ::geometry_msg::Quaternion* rotation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class Pose final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Pose(::google::protobuf::internal::ConstantInitialized);

  inline Pose(const Pose& from)
      : Pose(nullptr, from) {}
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Pose& from) {
    Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pose* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.Pose";
  }
  protected:
  explicit Pose(::google::protobuf::Arena* arena);
  Pose(::google::protobuf::Arena* arena, const Pose& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // .geometry_msg.Vector3 position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::geometry_msg::Vector3& position() const;
  PROTOBUF_NODISCARD ::geometry_msg::Vector3* release_position();
  ::geometry_msg::Vector3* mutable_position();
  void set_allocated_position(::geometry_msg::Vector3* value);
  void unsafe_arena_set_allocated_position(::geometry_msg::Vector3* value);
  ::geometry_msg::Vector3* unsafe_arena_release_position();

  private:
  const ::geometry_msg::Vector3& _internal_position() const;
  ::geometry_msg::Vector3* _internal_mutable_position();

  public:
  // .geometry_msg.Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::geometry_msg::Quaternion& orientation() const;
  PROTOBUF_NODISCARD ::geometry_msg::Quaternion* release_orientation();
  ::geometry_msg::Quaternion* mutable_orientation();
  void set_allocated_orientation(::geometry_msg::Quaternion* value);
  void unsafe_arena_set_allocated_orientation(::geometry_msg::Quaternion* value);
  ::geometry_msg::Quaternion* unsafe_arena_release_orientation();

  private:
  const ::geometry_msg::Quaternion& _internal_orientation() const;
  ::geometry_msg::Quaternion* _internal_mutable_orientation();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.Pose)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::geometry_msg::Vector3* position_;
    ::geometry_msg::Quaternion* orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class Accel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.Accel) */ {
 public:
  inline Accel() : Accel(nullptr) {}
  ~Accel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Accel(::google::protobuf::internal::ConstantInitialized);

  inline Accel(const Accel& from)
      : Accel(nullptr, from) {}
  Accel(Accel&& from) noexcept
    : Accel() {
    *this = ::std::move(from);
  }

  inline Accel& operator=(const Accel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Accel& operator=(Accel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Accel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Accel* internal_default_instance() {
    return reinterpret_cast<const Accel*>(
               &_Accel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Accel& a, Accel& b) {
    a.Swap(&b);
  }
  inline void Swap(Accel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Accel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Accel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Accel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Accel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Accel& from) {
    Accel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Accel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.Accel";
  }
  protected:
  explicit Accel(::google::protobuf::Arena* arena);
  Accel(::google::protobuf::Arena* arena, const Accel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .geometry_msg.Vector3 linear = 1;
  bool has_linear() const;
  void clear_linear() ;
  const ::geometry_msg::Vector3& linear() const;
  PROTOBUF_NODISCARD ::geometry_msg::Vector3* release_linear();
  ::geometry_msg::Vector3* mutable_linear();
  void set_allocated_linear(::geometry_msg::Vector3* value);
  void unsafe_arena_set_allocated_linear(::geometry_msg::Vector3* value);
  ::geometry_msg::Vector3* unsafe_arena_release_linear();

  private:
  const ::geometry_msg::Vector3& _internal_linear() const;
  ::geometry_msg::Vector3* _internal_mutable_linear();

  public:
  // .geometry_msg.Vector3 angular = 2;
  bool has_angular() const;
  void clear_angular() ;
  const ::geometry_msg::Vector3& angular() const;
  PROTOBUF_NODISCARD ::geometry_msg::Vector3* release_angular();
  ::geometry_msg::Vector3* mutable_angular();
  void set_allocated_angular(::geometry_msg::Vector3* value);
  void unsafe_arena_set_allocated_angular(::geometry_msg::Vector3* value);
  ::geometry_msg::Vector3* unsafe_arena_release_angular();

  private:
  const ::geometry_msg::Vector3& _internal_angular() const;
  ::geometry_msg::Vector3* _internal_mutable_angular();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.Accel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::geometry_msg::Vector3* linear_;
    ::geometry_msg::Vector3* angular_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class TwistWithCovariance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.TwistWithCovariance) */ {
 public:
  inline TwistWithCovariance() : TwistWithCovariance(nullptr) {}
  ~TwistWithCovariance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TwistWithCovariance(::google::protobuf::internal::ConstantInitialized);

  inline TwistWithCovariance(const TwistWithCovariance& from)
      : TwistWithCovariance(nullptr, from) {}
  TwistWithCovariance(TwistWithCovariance&& from) noexcept
    : TwistWithCovariance() {
    *this = ::std::move(from);
  }

  inline TwistWithCovariance& operator=(const TwistWithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwistWithCovariance& operator=(TwistWithCovariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwistWithCovariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwistWithCovariance* internal_default_instance() {
    return reinterpret_cast<const TwistWithCovariance*>(
               &_TwistWithCovariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TwistWithCovariance& a, TwistWithCovariance& b) {
    a.Swap(&b);
  }
  inline void Swap(TwistWithCovariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwistWithCovariance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwistWithCovariance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwistWithCovariance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TwistWithCovariance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TwistWithCovariance& from) {
    TwistWithCovariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TwistWithCovariance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.TwistWithCovariance";
  }
  protected:
  explicit TwistWithCovariance(::google::protobuf::Arena* arena);
  TwistWithCovariance(::google::protobuf::Arena* arena, const TwistWithCovariance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 2,
    kTwistFieldNumber = 1,
  };
  // repeated double covariance = 2;
  int covariance_size() const;
  private:
  int _internal_covariance_size() const;

  public:
  void clear_covariance() ;
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::google::protobuf::RepeatedField<double>& covariance() const;
  ::google::protobuf::RepeatedField<double>* mutable_covariance();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_covariance() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_covariance();

  public:
  // .geometry_msg.Twist twist = 1;
  bool has_twist() const;
  void clear_twist() ;
  const ::geometry_msg::Twist& twist() const;
  PROTOBUF_NODISCARD ::geometry_msg::Twist* release_twist();
  ::geometry_msg::Twist* mutable_twist();
  void set_allocated_twist(::geometry_msg::Twist* value);
  void unsafe_arena_set_allocated_twist(::geometry_msg::Twist* value);
  ::geometry_msg::Twist* unsafe_arena_release_twist();

  private:
  const ::geometry_msg::Twist& _internal_twist() const;
  ::geometry_msg::Twist* _internal_mutable_twist();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.TwistWithCovariance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> covariance_;
    ::geometry_msg::Twist* twist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class TwistStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.TwistStamped) */ {
 public:
  inline TwistStamped() : TwistStamped(nullptr) {}
  ~TwistStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TwistStamped(::google::protobuf::internal::ConstantInitialized);

  inline TwistStamped(const TwistStamped& from)
      : TwistStamped(nullptr, from) {}
  TwistStamped(TwistStamped&& from) noexcept
    : TwistStamped() {
    *this = ::std::move(from);
  }

  inline TwistStamped& operator=(const TwistStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwistStamped& operator=(TwistStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwistStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwistStamped* internal_default_instance() {
    return reinterpret_cast<const TwistStamped*>(
               &_TwistStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TwistStamped& a, TwistStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(TwistStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwistStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwistStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwistStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TwistStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TwistStamped& from) {
    TwistStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TwistStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.TwistStamped";
  }
  protected:
  explicit TwistStamped(::google::protobuf::Arena* arena);
  TwistStamped(::google::protobuf::Arena* arena, const TwistStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTwistFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.Twist twist = 2;
  bool has_twist() const;
  void clear_twist() ;
  const ::geometry_msg::Twist& twist() const;
  PROTOBUF_NODISCARD ::geometry_msg::Twist* release_twist();
  ::geometry_msg::Twist* mutable_twist();
  void set_allocated_twist(::geometry_msg::Twist* value);
  void unsafe_arena_set_allocated_twist(::geometry_msg::Twist* value);
  ::geometry_msg::Twist* unsafe_arena_release_twist();

  private:
  const ::geometry_msg::Twist& _internal_twist() const;
  ::geometry_msg::Twist* _internal_mutable_twist();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.TwistStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::geometry_msg::Twist* twist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class TransformStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.TransformStamped) */ {
 public:
  inline TransformStamped() : TransformStamped(nullptr) {}
  ~TransformStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransformStamped(::google::protobuf::internal::ConstantInitialized);

  inline TransformStamped(const TransformStamped& from)
      : TransformStamped(nullptr, from) {}
  TransformStamped(TransformStamped&& from) noexcept
    : TransformStamped() {
    *this = ::std::move(from);
  }

  inline TransformStamped& operator=(const TransformStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformStamped& operator=(TransformStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformStamped* internal_default_instance() {
    return reinterpret_cast<const TransformStamped*>(
               &_TransformStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransformStamped& a, TransformStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransformStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransformStamped& from) {
    TransformStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransformStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.TransformStamped";
  }
  protected:
  explicit TransformStamped(::google::protobuf::Arena* arena);
  TransformStamped(::google::protobuf::Arena* arena, const TransformStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildframeidFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kTransformFieldNumber = 3,
  };
  // string childframeid = 2;
  void clear_childframeid() ;
  const std::string& childframeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_childframeid(Arg_&& arg, Args_... args);
  std::string* mutable_childframeid();
  PROTOBUF_NODISCARD std::string* release_childframeid();
  void set_allocated_childframeid(std::string* value);

  private:
  const std::string& _internal_childframeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_childframeid(
      const std::string& value);
  std::string* _internal_mutable_childframeid();

  public:
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.Transform transform = 3;
  bool has_transform() const;
  void clear_transform() ;
  const ::geometry_msg::Transform& transform() const;
  PROTOBUF_NODISCARD ::geometry_msg::Transform* release_transform();
  ::geometry_msg::Transform* mutable_transform();
  void set_allocated_transform(::geometry_msg::Transform* value);
  void unsafe_arena_set_allocated_transform(::geometry_msg::Transform* value);
  ::geometry_msg::Transform* unsafe_arena_release_transform();

  private:
  const ::geometry_msg::Transform& _internal_transform() const;
  ::geometry_msg::Transform* _internal_mutable_transform();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.TransformStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr childframeid_;
    ::std_msg::Header* header_;
    ::geometry_msg::Transform* transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class PoseWithCovariance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.PoseWithCovariance) */ {
 public:
  inline PoseWithCovariance() : PoseWithCovariance(nullptr) {}
  ~PoseWithCovariance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PoseWithCovariance(::google::protobuf::internal::ConstantInitialized);

  inline PoseWithCovariance(const PoseWithCovariance& from)
      : PoseWithCovariance(nullptr, from) {}
  PoseWithCovariance(PoseWithCovariance&& from) noexcept
    : PoseWithCovariance() {
    *this = ::std::move(from);
  }

  inline PoseWithCovariance& operator=(const PoseWithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseWithCovariance& operator=(PoseWithCovariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoseWithCovariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoseWithCovariance* internal_default_instance() {
    return reinterpret_cast<const PoseWithCovariance*>(
               &_PoseWithCovariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PoseWithCovariance& a, PoseWithCovariance& b) {
    a.Swap(&b);
  }
  inline void Swap(PoseWithCovariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseWithCovariance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoseWithCovariance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoseWithCovariance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PoseWithCovariance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PoseWithCovariance& from) {
    PoseWithCovariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PoseWithCovariance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.PoseWithCovariance";
  }
  protected:
  explicit PoseWithCovariance(::google::protobuf::Arena* arena);
  PoseWithCovariance(::google::protobuf::Arena* arena, const PoseWithCovariance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 2,
    kPoseFieldNumber = 1,
  };
  // repeated double covariance = 2;
  int covariance_size() const;
  private:
  int _internal_covariance_size() const;

  public:
  void clear_covariance() ;
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::google::protobuf::RepeatedField<double>& covariance() const;
  ::google::protobuf::RepeatedField<double>* mutable_covariance();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_covariance() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_covariance();

  public:
  // .geometry_msg.Pose pose = 1;
  bool has_pose() const;
  void clear_pose() ;
  const ::geometry_msg::Pose& pose() const;
  PROTOBUF_NODISCARD ::geometry_msg::Pose* release_pose();
  ::geometry_msg::Pose* mutable_pose();
  void set_allocated_pose(::geometry_msg::Pose* value);
  void unsafe_arena_set_allocated_pose(::geometry_msg::Pose* value);
  ::geometry_msg::Pose* unsafe_arena_release_pose();

  private:
  const ::geometry_msg::Pose& _internal_pose() const;
  ::geometry_msg::Pose* _internal_mutable_pose();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.PoseWithCovariance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> covariance_;
    ::geometry_msg::Pose* pose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class PoseStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.PoseStamped) */ {
 public:
  inline PoseStamped() : PoseStamped(nullptr) {}
  ~PoseStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PoseStamped(::google::protobuf::internal::ConstantInitialized);

  inline PoseStamped(const PoseStamped& from)
      : PoseStamped(nullptr, from) {}
  PoseStamped(PoseStamped&& from) noexcept
    : PoseStamped() {
    *this = ::std::move(from);
  }

  inline PoseStamped& operator=(const PoseStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseStamped& operator=(PoseStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoseStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoseStamped* internal_default_instance() {
    return reinterpret_cast<const PoseStamped*>(
               &_PoseStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PoseStamped& a, PoseStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(PoseStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoseStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoseStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PoseStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PoseStamped& from) {
    PoseStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PoseStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.PoseStamped";
  }
  protected:
  explicit PoseStamped(::google::protobuf::Arena* arena);
  PoseStamped(::google::protobuf::Arena* arena, const PoseStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPoseFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.Pose pose = 2;
  bool has_pose() const;
  void clear_pose() ;
  const ::geometry_msg::Pose& pose() const;
  PROTOBUF_NODISCARD ::geometry_msg::Pose* release_pose();
  ::geometry_msg::Pose* mutable_pose();
  void set_allocated_pose(::geometry_msg::Pose* value);
  void unsafe_arena_set_allocated_pose(::geometry_msg::Pose* value);
  ::geometry_msg::Pose* unsafe_arena_release_pose();

  private:
  const ::geometry_msg::Pose& _internal_pose() const;
  ::geometry_msg::Pose* _internal_mutable_pose();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.PoseStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::geometry_msg::Pose* pose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class AccelWithCovariance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.AccelWithCovariance) */ {
 public:
  inline AccelWithCovariance() : AccelWithCovariance(nullptr) {}
  ~AccelWithCovariance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccelWithCovariance(::google::protobuf::internal::ConstantInitialized);

  inline AccelWithCovariance(const AccelWithCovariance& from)
      : AccelWithCovariance(nullptr, from) {}
  AccelWithCovariance(AccelWithCovariance&& from) noexcept
    : AccelWithCovariance() {
    *this = ::std::move(from);
  }

  inline AccelWithCovariance& operator=(const AccelWithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelWithCovariance& operator=(AccelWithCovariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelWithCovariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelWithCovariance* internal_default_instance() {
    return reinterpret_cast<const AccelWithCovariance*>(
               &_AccelWithCovariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccelWithCovariance& a, AccelWithCovariance& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelWithCovariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelWithCovariance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelWithCovariance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelWithCovariance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccelWithCovariance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AccelWithCovariance& from) {
    AccelWithCovariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AccelWithCovariance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.AccelWithCovariance";
  }
  protected:
  explicit AccelWithCovariance(::google::protobuf::Arena* arena);
  AccelWithCovariance(::google::protobuf::Arena* arena, const AccelWithCovariance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 2,
    kAccelFieldNumber = 1,
  };
  // repeated double covariance = 2;
  int covariance_size() const;
  private:
  int _internal_covariance_size() const;

  public:
  void clear_covariance() ;
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::google::protobuf::RepeatedField<double>& covariance() const;
  ::google::protobuf::RepeatedField<double>* mutable_covariance();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_covariance() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_covariance();

  public:
  // .geometry_msg.Accel accel = 1;
  bool has_accel() const;
  void clear_accel() ;
  const ::geometry_msg::Accel& accel() const;
  PROTOBUF_NODISCARD ::geometry_msg::Accel* release_accel();
  ::geometry_msg::Accel* mutable_accel();
  void set_allocated_accel(::geometry_msg::Accel* value);
  void unsafe_arena_set_allocated_accel(::geometry_msg::Accel* value);
  ::geometry_msg::Accel* unsafe_arena_release_accel();

  private:
  const ::geometry_msg::Accel& _internal_accel() const;
  ::geometry_msg::Accel* _internal_mutable_accel();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.AccelWithCovariance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> covariance_;
    ::geometry_msg::Accel* accel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class AccelStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.AccelStamped) */ {
 public:
  inline AccelStamped() : AccelStamped(nullptr) {}
  ~AccelStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccelStamped(::google::protobuf::internal::ConstantInitialized);

  inline AccelStamped(const AccelStamped& from)
      : AccelStamped(nullptr, from) {}
  AccelStamped(AccelStamped&& from) noexcept
    : AccelStamped() {
    *this = ::std::move(from);
  }

  inline AccelStamped& operator=(const AccelStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelStamped& operator=(AccelStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelStamped* internal_default_instance() {
    return reinterpret_cast<const AccelStamped*>(
               &_AccelStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AccelStamped& a, AccelStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccelStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AccelStamped& from) {
    AccelStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AccelStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.AccelStamped";
  }
  protected:
  explicit AccelStamped(::google::protobuf::Arena* arena);
  AccelStamped(::google::protobuf::Arena* arena, const AccelStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAccelFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.Accel accel = 2;
  bool has_accel() const;
  void clear_accel() ;
  const ::geometry_msg::Accel& accel() const;
  PROTOBUF_NODISCARD ::geometry_msg::Accel* release_accel();
  ::geometry_msg::Accel* mutable_accel();
  void set_allocated_accel(::geometry_msg::Accel* value);
  void unsafe_arena_set_allocated_accel(::geometry_msg::Accel* value);
  ::geometry_msg::Accel* unsafe_arena_release_accel();

  private:
  const ::geometry_msg::Accel& _internal_accel() const;
  ::geometry_msg::Accel* _internal_mutable_accel();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.AccelStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::geometry_msg::Accel* accel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class TwistWithCovarianceStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.TwistWithCovarianceStamped) */ {
 public:
  inline TwistWithCovarianceStamped() : TwistWithCovarianceStamped(nullptr) {}
  ~TwistWithCovarianceStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TwistWithCovarianceStamped(::google::protobuf::internal::ConstantInitialized);

  inline TwistWithCovarianceStamped(const TwistWithCovarianceStamped& from)
      : TwistWithCovarianceStamped(nullptr, from) {}
  TwistWithCovarianceStamped(TwistWithCovarianceStamped&& from) noexcept
    : TwistWithCovarianceStamped() {
    *this = ::std::move(from);
  }

  inline TwistWithCovarianceStamped& operator=(const TwistWithCovarianceStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwistWithCovarianceStamped& operator=(TwistWithCovarianceStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwistWithCovarianceStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwistWithCovarianceStamped* internal_default_instance() {
    return reinterpret_cast<const TwistWithCovarianceStamped*>(
               &_TwistWithCovarianceStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TwistWithCovarianceStamped& a, TwistWithCovarianceStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(TwistWithCovarianceStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwistWithCovarianceStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwistWithCovarianceStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwistWithCovarianceStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TwistWithCovarianceStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TwistWithCovarianceStamped& from) {
    TwistWithCovarianceStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TwistWithCovarianceStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.TwistWithCovarianceStamped";
  }
  protected:
  explicit TwistWithCovarianceStamped(::google::protobuf::Arena* arena);
  TwistWithCovarianceStamped(::google::protobuf::Arena* arena, const TwistWithCovarianceStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTwistFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.TwistWithCovariance twist = 2;
  bool has_twist() const;
  void clear_twist() ;
  const ::geometry_msg::TwistWithCovariance& twist() const;
  PROTOBUF_NODISCARD ::geometry_msg::TwistWithCovariance* release_twist();
  ::geometry_msg::TwistWithCovariance* mutable_twist();
  void set_allocated_twist(::geometry_msg::TwistWithCovariance* value);
  void unsafe_arena_set_allocated_twist(::geometry_msg::TwistWithCovariance* value);
  ::geometry_msg::TwistWithCovariance* unsafe_arena_release_twist();

  private:
  const ::geometry_msg::TwistWithCovariance& _internal_twist() const;
  ::geometry_msg::TwistWithCovariance* _internal_mutable_twist();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.TwistWithCovarianceStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::geometry_msg::TwistWithCovariance* twist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class PoseWithCovarianceStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.PoseWithCovarianceStamped) */ {
 public:
  inline PoseWithCovarianceStamped() : PoseWithCovarianceStamped(nullptr) {}
  ~PoseWithCovarianceStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PoseWithCovarianceStamped(::google::protobuf::internal::ConstantInitialized);

  inline PoseWithCovarianceStamped(const PoseWithCovarianceStamped& from)
      : PoseWithCovarianceStamped(nullptr, from) {}
  PoseWithCovarianceStamped(PoseWithCovarianceStamped&& from) noexcept
    : PoseWithCovarianceStamped() {
    *this = ::std::move(from);
  }

  inline PoseWithCovarianceStamped& operator=(const PoseWithCovarianceStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseWithCovarianceStamped& operator=(PoseWithCovarianceStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoseWithCovarianceStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoseWithCovarianceStamped* internal_default_instance() {
    return reinterpret_cast<const PoseWithCovarianceStamped*>(
               &_PoseWithCovarianceStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PoseWithCovarianceStamped& a, PoseWithCovarianceStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(PoseWithCovarianceStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseWithCovarianceStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoseWithCovarianceStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoseWithCovarianceStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PoseWithCovarianceStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PoseWithCovarianceStamped& from) {
    PoseWithCovarianceStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PoseWithCovarianceStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.PoseWithCovarianceStamped";
  }
  protected:
  explicit PoseWithCovarianceStamped(::google::protobuf::Arena* arena);
  PoseWithCovarianceStamped(::google::protobuf::Arena* arena, const PoseWithCovarianceStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPoseFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.PoseWithCovariance pose = 2;
  bool has_pose() const;
  void clear_pose() ;
  const ::geometry_msg::PoseWithCovariance& pose() const;
  PROTOBUF_NODISCARD ::geometry_msg::PoseWithCovariance* release_pose();
  ::geometry_msg::PoseWithCovariance* mutable_pose();
  void set_allocated_pose(::geometry_msg::PoseWithCovariance* value);
  void unsafe_arena_set_allocated_pose(::geometry_msg::PoseWithCovariance* value);
  ::geometry_msg::PoseWithCovariance* unsafe_arena_release_pose();

  private:
  const ::geometry_msg::PoseWithCovariance& _internal_pose() const;
  ::geometry_msg::PoseWithCovariance* _internal_mutable_pose();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.PoseWithCovarianceStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::geometry_msg::PoseWithCovariance* pose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};// -------------------------------------------------------------------

class AccelWithCovarianceStamped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geometry_msg.AccelWithCovarianceStamped) */ {
 public:
  inline AccelWithCovarianceStamped() : AccelWithCovarianceStamped(nullptr) {}
  ~AccelWithCovarianceStamped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccelWithCovarianceStamped(::google::protobuf::internal::ConstantInitialized);

  inline AccelWithCovarianceStamped(const AccelWithCovarianceStamped& from)
      : AccelWithCovarianceStamped(nullptr, from) {}
  AccelWithCovarianceStamped(AccelWithCovarianceStamped&& from) noexcept
    : AccelWithCovarianceStamped() {
    *this = ::std::move(from);
  }

  inline AccelWithCovarianceStamped& operator=(const AccelWithCovarianceStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelWithCovarianceStamped& operator=(AccelWithCovarianceStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelWithCovarianceStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelWithCovarianceStamped* internal_default_instance() {
    return reinterpret_cast<const AccelWithCovarianceStamped*>(
               &_AccelWithCovarianceStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AccelWithCovarianceStamped& a, AccelWithCovarianceStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelWithCovarianceStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelWithCovarianceStamped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelWithCovarianceStamped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelWithCovarianceStamped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccelWithCovarianceStamped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AccelWithCovarianceStamped& from) {
    AccelWithCovarianceStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AccelWithCovarianceStamped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "geometry_msg.AccelWithCovarianceStamped";
  }
  protected:
  explicit AccelWithCovarianceStamped(::google::protobuf::Arena* arena);
  AccelWithCovarianceStamped(::google::protobuf::Arena* arena, const AccelWithCovarianceStamped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAccelFieldNumber = 2,
  };
  // .std_msg.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::std_msg::Header& header() const;
  PROTOBUF_NODISCARD ::std_msg::Header* release_header();
  ::std_msg::Header* mutable_header();
  void set_allocated_header(::std_msg::Header* value);
  void unsafe_arena_set_allocated_header(::std_msg::Header* value);
  ::std_msg::Header* unsafe_arena_release_header();

  private:
  const ::std_msg::Header& _internal_header() const;
  ::std_msg::Header* _internal_mutable_header();

  public:
  // .geometry_msg.AccelWithCovariance accel = 2;
  bool has_accel() const;
  void clear_accel() ;
  const ::geometry_msg::AccelWithCovariance& accel() const;
  PROTOBUF_NODISCARD ::geometry_msg::AccelWithCovariance* release_accel();
  ::geometry_msg::AccelWithCovariance* mutable_accel();
  void set_allocated_accel(::geometry_msg::AccelWithCovariance* value);
  void unsafe_arena_set_allocated_accel(::geometry_msg::AccelWithCovariance* value);
  ::geometry_msg::AccelWithCovariance* unsafe_arena_release_accel();

  private:
  const ::geometry_msg::AccelWithCovariance& _internal_accel() const;
  ::geometry_msg::AccelWithCovariance* _internal_mutable_accel();

  public:
  // @@protoc_insertion_point(class_scope:geometry_msg.AccelWithCovarianceStamped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::std_msg::Header* header_;
    ::geometry_msg::AccelWithCovariance* accel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geometry_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3

// double x = 1;
inline void Vector3::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Vector3.x)
}
inline double Vector3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Vector3::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Vector3.y)
}
inline double Vector3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3;
inline void Vector3::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Vector3.z)
}
inline double Vector3::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Accel

// .geometry_msg.Vector3 linear = 1;
inline bool Accel::has_linear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_ != nullptr);
  return value;
}
inline void Accel::clear_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.linear_ != nullptr) _impl_.linear_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Vector3& Accel::_internal_linear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Vector3* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Vector3&>(::geometry_msg::_Vector3_default_instance_);
}
inline const ::geometry_msg::Vector3& Accel::linear() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Accel.linear)
  return _internal_linear();
}
inline void Accel::unsafe_arena_set_allocated_linear(::geometry_msg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Accel.linear)
}
inline ::geometry_msg::Vector3* Accel::release_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* released = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Vector3* Accel::unsafe_arena_release_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Accel.linear)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::geometry_msg::Vector3* Accel::_internal_mutable_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Vector3>(GetArena());
    _impl_.linear_ = reinterpret_cast<::geometry_msg::Vector3*>(p);
  }
  return _impl_.linear_;
}
inline ::geometry_msg::Vector3* Accel::mutable_linear() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Vector3* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Accel.linear)
  return _msg;
}
inline void Accel::set_allocated_linear(::geometry_msg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Vector3*>(_impl_.linear_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.linear_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Accel.linear)
}

// .geometry_msg.Vector3 angular = 2;
inline bool Accel::has_angular() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_ != nullptr);
  return value;
}
inline void Accel::clear_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.angular_ != nullptr) _impl_.angular_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Vector3& Accel::_internal_angular() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Vector3* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Vector3&>(::geometry_msg::_Vector3_default_instance_);
}
inline const ::geometry_msg::Vector3& Accel::angular() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Accel.angular)
  return _internal_angular();
}
inline void Accel::unsafe_arena_set_allocated_angular(::geometry_msg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Accel.angular)
}
inline ::geometry_msg::Vector3* Accel::release_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Vector3* released = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Vector3* Accel::unsafe_arena_release_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Accel.angular)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Vector3* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::geometry_msg::Vector3* Accel::_internal_mutable_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Vector3>(GetArena());
    _impl_.angular_ = reinterpret_cast<::geometry_msg::Vector3*>(p);
  }
  return _impl_.angular_;
}
inline ::geometry_msg::Vector3* Accel::mutable_angular() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Vector3* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Accel.angular)
  return _msg;
}
inline void Accel::set_allocated_angular(::geometry_msg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Vector3*>(_impl_.angular_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.angular_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Accel.angular)
}

// -------------------------------------------------------------------

// AccelStamped

// .std_msg.Header header = 1;
inline bool AccelStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& AccelStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& AccelStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.AccelStamped.header)
  return _internal_header();
}
inline void AccelStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.AccelStamped.header)
}
inline ::std_msg::Header* AccelStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* AccelStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.AccelStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* AccelStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* AccelStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.AccelStamped.header)
  return _msg;
}
inline void AccelStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.AccelStamped.header)
}

// .geometry_msg.Accel accel = 2;
inline bool AccelStamped::has_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accel_ != nullptr);
  return value;
}
inline void AccelStamped::clear_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accel_ != nullptr) _impl_.accel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Accel& AccelStamped::_internal_accel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Accel* p = _impl_.accel_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Accel&>(::geometry_msg::_Accel_default_instance_);
}
inline const ::geometry_msg::Accel& AccelStamped::accel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.AccelStamped.accel)
  return _internal_accel();
}
inline void AccelStamped::unsafe_arena_set_allocated_accel(::geometry_msg::Accel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accel_);
  }
  _impl_.accel_ = reinterpret_cast<::geometry_msg::Accel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.AccelStamped.accel)
}
inline ::geometry_msg::Accel* AccelStamped::release_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Accel* released = _impl_.accel_;
  _impl_.accel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Accel* AccelStamped::unsafe_arena_release_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.AccelStamped.accel)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Accel* temp = _impl_.accel_;
  _impl_.accel_ = nullptr;
  return temp;
}
inline ::geometry_msg::Accel* AccelStamped::_internal_mutable_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.accel_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Accel>(GetArena());
    _impl_.accel_ = reinterpret_cast<::geometry_msg::Accel*>(p);
  }
  return _impl_.accel_;
}
inline ::geometry_msg::Accel* AccelStamped::mutable_accel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Accel* _msg = _internal_mutable_accel();
  // @@protoc_insertion_point(field_mutable:geometry_msg.AccelStamped.accel)
  return _msg;
}
inline void AccelStamped::set_allocated_accel(::geometry_msg::Accel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Accel*>(_impl_.accel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Accel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.accel_ = reinterpret_cast<::geometry_msg::Accel*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.AccelStamped.accel)
}

// -------------------------------------------------------------------

// AccelWithCovariance

// .geometry_msg.Accel accel = 1;
inline bool AccelWithCovariance::has_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accel_ != nullptr);
  return value;
}
inline void AccelWithCovariance::clear_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accel_ != nullptr) _impl_.accel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Accel& AccelWithCovariance::_internal_accel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Accel* p = _impl_.accel_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Accel&>(::geometry_msg::_Accel_default_instance_);
}
inline const ::geometry_msg::Accel& AccelWithCovariance::accel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.AccelWithCovariance.accel)
  return _internal_accel();
}
inline void AccelWithCovariance::unsafe_arena_set_allocated_accel(::geometry_msg::Accel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accel_);
  }
  _impl_.accel_ = reinterpret_cast<::geometry_msg::Accel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.AccelWithCovariance.accel)
}
inline ::geometry_msg::Accel* AccelWithCovariance::release_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Accel* released = _impl_.accel_;
  _impl_.accel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Accel* AccelWithCovariance::unsafe_arena_release_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.AccelWithCovariance.accel)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Accel* temp = _impl_.accel_;
  _impl_.accel_ = nullptr;
  return temp;
}
inline ::geometry_msg::Accel* AccelWithCovariance::_internal_mutable_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.accel_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Accel>(GetArena());
    _impl_.accel_ = reinterpret_cast<::geometry_msg::Accel*>(p);
  }
  return _impl_.accel_;
}
inline ::geometry_msg::Accel* AccelWithCovariance::mutable_accel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Accel* _msg = _internal_mutable_accel();
  // @@protoc_insertion_point(field_mutable:geometry_msg.AccelWithCovariance.accel)
  return _msg;
}
inline void AccelWithCovariance::set_allocated_accel(::geometry_msg::Accel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Accel*>(_impl_.accel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Accel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.accel_ = reinterpret_cast<::geometry_msg::Accel*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.AccelWithCovariance.accel)
}

// repeated double covariance = 2;
inline int AccelWithCovariance::_internal_covariance_size() const {
  return _internal_covariance().size();
}
inline int AccelWithCovariance::covariance_size() const {
  return _internal_covariance_size();
}
inline void AccelWithCovariance::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.covariance_.Clear();
}
inline double AccelWithCovariance::covariance(int index) const {
  // @@protoc_insertion_point(field_get:geometry_msg.AccelWithCovariance.covariance)
  return _internal_covariance().Get(index);
}
inline void AccelWithCovariance::set_covariance(int index, double value) {
  _internal_mutable_covariance()->Set(index, value);
  // @@protoc_insertion_point(field_set:geometry_msg.AccelWithCovariance.covariance)
}
inline void AccelWithCovariance::add_covariance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_covariance()->Add(value);
  // @@protoc_insertion_point(field_add:geometry_msg.AccelWithCovariance.covariance)
}
inline const ::google::protobuf::RepeatedField<double>& AccelWithCovariance::covariance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geometry_msg.AccelWithCovariance.covariance)
  return _internal_covariance();
}
inline ::google::protobuf::RepeatedField<double>* AccelWithCovariance::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geometry_msg.AccelWithCovariance.covariance)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_covariance();
}
inline const ::google::protobuf::RepeatedField<double>& AccelWithCovariance::_internal_covariance()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.covariance_;
}
inline ::google::protobuf::RepeatedField<double>* AccelWithCovariance::_internal_mutable_covariance() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.covariance_;
}

// -------------------------------------------------------------------

// AccelWithCovarianceStamped

// .std_msg.Header header = 1;
inline bool AccelWithCovarianceStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& AccelWithCovarianceStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& AccelWithCovarianceStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.AccelWithCovarianceStamped.header)
  return _internal_header();
}
inline void AccelWithCovarianceStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.AccelWithCovarianceStamped.header)
}
inline ::std_msg::Header* AccelWithCovarianceStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* AccelWithCovarianceStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.AccelWithCovarianceStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* AccelWithCovarianceStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* AccelWithCovarianceStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.AccelWithCovarianceStamped.header)
  return _msg;
}
inline void AccelWithCovarianceStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.AccelWithCovarianceStamped.header)
}

// .geometry_msg.AccelWithCovariance accel = 2;
inline bool AccelWithCovarianceStamped::has_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accel_ != nullptr);
  return value;
}
inline void AccelWithCovarianceStamped::clear_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accel_ != nullptr) _impl_.accel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::AccelWithCovariance& AccelWithCovarianceStamped::_internal_accel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::AccelWithCovariance* p = _impl_.accel_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::AccelWithCovariance&>(::geometry_msg::_AccelWithCovariance_default_instance_);
}
inline const ::geometry_msg::AccelWithCovariance& AccelWithCovarianceStamped::accel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.AccelWithCovarianceStamped.accel)
  return _internal_accel();
}
inline void AccelWithCovarianceStamped::unsafe_arena_set_allocated_accel(::geometry_msg::AccelWithCovariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accel_);
  }
  _impl_.accel_ = reinterpret_cast<::geometry_msg::AccelWithCovariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.AccelWithCovarianceStamped.accel)
}
inline ::geometry_msg::AccelWithCovariance* AccelWithCovarianceStamped::release_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::AccelWithCovariance* released = _impl_.accel_;
  _impl_.accel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::AccelWithCovariance* AccelWithCovarianceStamped::unsafe_arena_release_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.AccelWithCovarianceStamped.accel)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::AccelWithCovariance* temp = _impl_.accel_;
  _impl_.accel_ = nullptr;
  return temp;
}
inline ::geometry_msg::AccelWithCovariance* AccelWithCovarianceStamped::_internal_mutable_accel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.accel_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::AccelWithCovariance>(GetArena());
    _impl_.accel_ = reinterpret_cast<::geometry_msg::AccelWithCovariance*>(p);
  }
  return _impl_.accel_;
}
inline ::geometry_msg::AccelWithCovariance* AccelWithCovarianceStamped::mutable_accel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::AccelWithCovariance* _msg = _internal_mutable_accel();
  // @@protoc_insertion_point(field_mutable:geometry_msg.AccelWithCovarianceStamped.accel)
  return _msg;
}
inline void AccelWithCovarianceStamped::set_allocated_accel(::geometry_msg::AccelWithCovariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::AccelWithCovariance*>(_impl_.accel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::AccelWithCovariance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.accel_ = reinterpret_cast<::geometry_msg::AccelWithCovariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.AccelWithCovarianceStamped.accel)
}

// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Quaternion.x)
}
inline double Quaternion::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Quaternion::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2;
inline void Quaternion::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Quaternion.y)
}
inline double Quaternion::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Quaternion::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3;
inline void Quaternion::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Quaternion.z)
}
inline double Quaternion::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Quaternion::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// double w = 4;
inline void Quaternion::clear_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.w_ = 0;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:geometry_msg.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:geometry_msg.Quaternion.w)
}
inline double Quaternion::_internal_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.w_;
}
inline void Quaternion::_internal_set_w(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.w_ = value;
}

// -------------------------------------------------------------------

// Pose

// .geometry_msg.Vector3 position = 1;
inline bool Pose::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Pose::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Vector3& Pose::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Vector3&>(::geometry_msg::_Vector3_default_instance_);
}
inline const ::geometry_msg::Vector3& Pose::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(::geometry_msg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Pose.position)
}
inline ::geometry_msg::Vector3* Pose::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Vector3* Pose::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Pose.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::geometry_msg::Vector3* Pose::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::geometry_msg::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::geometry_msg::Vector3* Pose::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Pose.position)
  return _msg;
}
inline void Pose::set_allocated_position(::geometry_msg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Vector3*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Pose.position)
}

// .geometry_msg.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void Pose::clear_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Quaternion& Pose::_internal_orientation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Quaternion* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Quaternion&>(::geometry_msg::_Quaternion_default_instance_);
}
inline const ::geometry_msg::Quaternion& Pose::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Pose.orientation)
  return _internal_orientation();
}
inline void Pose::unsafe_arena_set_allocated_orientation(::geometry_msg::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::geometry_msg::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Pose.orientation)
}
inline ::geometry_msg::Quaternion* Pose::release_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Quaternion* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Quaternion* Pose::unsafe_arena_release_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Pose.orientation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Quaternion* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::geometry_msg::Quaternion* Pose::_internal_mutable_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Quaternion>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::geometry_msg::Quaternion*>(p);
  }
  return _impl_.orientation_;
}
inline ::geometry_msg::Quaternion* Pose::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Quaternion* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Pose.orientation)
  return _msg;
}
inline void Pose::set_allocated_orientation(::geometry_msg::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Quaternion*>(_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_ = reinterpret_cast<::geometry_msg::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Pose.orientation)
}

// -------------------------------------------------------------------

// PoseStamped

// .std_msg.Header header = 1;
inline bool PoseStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& PoseStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& PoseStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.PoseStamped.header)
  return _internal_header();
}
inline void PoseStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.PoseStamped.header)
}
inline ::std_msg::Header* PoseStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* PoseStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.PoseStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* PoseStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* PoseStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.PoseStamped.header)
  return _msg;
}
inline void PoseStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.PoseStamped.header)
}

// .geometry_msg.Pose pose = 2;
inline bool PoseStamped::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void PoseStamped::clear_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Pose& PoseStamped::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Pose&>(::geometry_msg::_Pose_default_instance_);
}
inline const ::geometry_msg::Pose& PoseStamped::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.PoseStamped.pose)
  return _internal_pose();
}
inline void PoseStamped::unsafe_arena_set_allocated_pose(::geometry_msg::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.PoseStamped.pose)
}
inline ::geometry_msg::Pose* PoseStamped::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Pose* PoseStamped::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.PoseStamped.pose)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::geometry_msg::Pose* PoseStamped::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::geometry_msg::Pose* PoseStamped::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:geometry_msg.PoseStamped.pose)
  return _msg;
}
inline void PoseStamped::set_allocated_pose(::geometry_msg::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Pose*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Pose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.PoseStamped.pose)
}

// -------------------------------------------------------------------

// PoseWithCovariance

// .geometry_msg.Pose pose = 1;
inline bool PoseWithCovariance::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void PoseWithCovariance::clear_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Pose& PoseWithCovariance::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Pose&>(::geometry_msg::_Pose_default_instance_);
}
inline const ::geometry_msg::Pose& PoseWithCovariance::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.PoseWithCovariance.pose)
  return _internal_pose();
}
inline void PoseWithCovariance::unsafe_arena_set_allocated_pose(::geometry_msg::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.PoseWithCovariance.pose)
}
inline ::geometry_msg::Pose* PoseWithCovariance::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Pose* PoseWithCovariance::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.PoseWithCovariance.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::geometry_msg::Pose* PoseWithCovariance::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::geometry_msg::Pose* PoseWithCovariance::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:geometry_msg.PoseWithCovariance.pose)
  return _msg;
}
inline void PoseWithCovariance::set_allocated_pose(::geometry_msg::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Pose*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Pose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::geometry_msg::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.PoseWithCovariance.pose)
}

// repeated double covariance = 2;
inline int PoseWithCovariance::_internal_covariance_size() const {
  return _internal_covariance().size();
}
inline int PoseWithCovariance::covariance_size() const {
  return _internal_covariance_size();
}
inline void PoseWithCovariance::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.covariance_.Clear();
}
inline double PoseWithCovariance::covariance(int index) const {
  // @@protoc_insertion_point(field_get:geometry_msg.PoseWithCovariance.covariance)
  return _internal_covariance().Get(index);
}
inline void PoseWithCovariance::set_covariance(int index, double value) {
  _internal_mutable_covariance()->Set(index, value);
  // @@protoc_insertion_point(field_set:geometry_msg.PoseWithCovariance.covariance)
}
inline void PoseWithCovariance::add_covariance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_covariance()->Add(value);
  // @@protoc_insertion_point(field_add:geometry_msg.PoseWithCovariance.covariance)
}
inline const ::google::protobuf::RepeatedField<double>& PoseWithCovariance::covariance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geometry_msg.PoseWithCovariance.covariance)
  return _internal_covariance();
}
inline ::google::protobuf::RepeatedField<double>* PoseWithCovariance::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geometry_msg.PoseWithCovariance.covariance)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_covariance();
}
inline const ::google::protobuf::RepeatedField<double>& PoseWithCovariance::_internal_covariance()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.covariance_;
}
inline ::google::protobuf::RepeatedField<double>* PoseWithCovariance::_internal_mutable_covariance() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.covariance_;
}

// -------------------------------------------------------------------

// PoseWithCovarianceStamped

// .std_msg.Header header = 1;
inline bool PoseWithCovarianceStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& PoseWithCovarianceStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& PoseWithCovarianceStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.PoseWithCovarianceStamped.header)
  return _internal_header();
}
inline void PoseWithCovarianceStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.PoseWithCovarianceStamped.header)
}
inline ::std_msg::Header* PoseWithCovarianceStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* PoseWithCovarianceStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.PoseWithCovarianceStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* PoseWithCovarianceStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* PoseWithCovarianceStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.PoseWithCovarianceStamped.header)
  return _msg;
}
inline void PoseWithCovarianceStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.PoseWithCovarianceStamped.header)
}

// .geometry_msg.PoseWithCovariance pose = 2;
inline bool PoseWithCovarianceStamped::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void PoseWithCovarianceStamped::clear_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::PoseWithCovariance& PoseWithCovarianceStamped::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::PoseWithCovariance* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::PoseWithCovariance&>(::geometry_msg::_PoseWithCovariance_default_instance_);
}
inline const ::geometry_msg::PoseWithCovariance& PoseWithCovarianceStamped::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.PoseWithCovarianceStamped.pose)
  return _internal_pose();
}
inline void PoseWithCovarianceStamped::unsafe_arena_set_allocated_pose(::geometry_msg::PoseWithCovariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.PoseWithCovarianceStamped.pose)
}
inline ::geometry_msg::PoseWithCovariance* PoseWithCovarianceStamped::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::PoseWithCovariance* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::PoseWithCovariance* PoseWithCovarianceStamped::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.PoseWithCovarianceStamped.pose)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::PoseWithCovariance* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::geometry_msg::PoseWithCovariance* PoseWithCovarianceStamped::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::PoseWithCovariance>(GetArena());
    _impl_.pose_ = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(p);
  }
  return _impl_.pose_;
}
inline ::geometry_msg::PoseWithCovariance* PoseWithCovarianceStamped::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::PoseWithCovariance* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:geometry_msg.PoseWithCovarianceStamped.pose)
  return _msg;
}
inline void PoseWithCovarianceStamped::set_allocated_pose(::geometry_msg::PoseWithCovariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::PoseWithCovariance*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pose_ = reinterpret_cast<::geometry_msg::PoseWithCovariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.PoseWithCovarianceStamped.pose)
}

// -------------------------------------------------------------------

// Transform

// .geometry_msg.Vector3 translation = 1;
inline bool Transform::has_translation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.translation_ != nullptr);
  return value;
}
inline void Transform::clear_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.translation_ != nullptr) _impl_.translation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Vector3& Transform::_internal_translation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Vector3* p = _impl_.translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Vector3&>(::geometry_msg::_Vector3_default_instance_);
}
inline const ::geometry_msg::Vector3& Transform::translation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Transform.translation)
  return _internal_translation();
}
inline void Transform::unsafe_arena_set_allocated_translation(::geometry_msg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.translation_);
  }
  _impl_.translation_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Transform.translation)
}
inline ::geometry_msg::Vector3* Transform::release_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* released = _impl_.translation_;
  _impl_.translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Vector3* Transform::unsafe_arena_release_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Transform.translation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
  return temp;
}
inline ::geometry_msg::Vector3* Transform::_internal_mutable_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Vector3>(GetArena());
    _impl_.translation_ = reinterpret_cast<::geometry_msg::Vector3*>(p);
  }
  return _impl_.translation_;
}
inline ::geometry_msg::Vector3* Transform::mutable_translation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Vector3* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Transform.translation)
  return _msg;
}
inline void Transform::set_allocated_translation(::geometry_msg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Vector3*>(_impl_.translation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.translation_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Transform.translation)
}

// .geometry_msg.Quaternion rotation = 2;
inline bool Transform::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Transform::clear_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Quaternion& Transform::_internal_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Quaternion&>(::geometry_msg::_Quaternion_default_instance_);
}
inline const ::geometry_msg::Quaternion& Transform::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Transform.rotation)
  return _internal_rotation();
}
inline void Transform::unsafe_arena_set_allocated_rotation(::geometry_msg::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::geometry_msg::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Transform.rotation)
}
inline ::geometry_msg::Quaternion* Transform::release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Quaternion* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Quaternion* Transform::unsafe_arena_release_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Transform.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::geometry_msg::Quaternion* Transform::_internal_mutable_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Quaternion>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::geometry_msg::Quaternion*>(p);
  }
  return _impl_.rotation_;
}
inline ::geometry_msg::Quaternion* Transform::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Transform.rotation)
  return _msg;
}
inline void Transform::set_allocated_rotation(::geometry_msg::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Quaternion*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::geometry_msg::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Transform.rotation)
}

// -------------------------------------------------------------------

// TransformStamped

// .std_msg.Header header = 1;
inline bool TransformStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& TransformStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& TransformStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TransformStamped.header)
  return _internal_header();
}
inline void TransformStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TransformStamped.header)
}
inline ::std_msg::Header* TransformStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* TransformStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TransformStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* TransformStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* TransformStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TransformStamped.header)
  return _msg;
}
inline void TransformStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TransformStamped.header)
}

// string childframeid = 2;
inline void TransformStamped::clear_childframeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.childframeid_.ClearToEmpty();
}
inline const std::string& TransformStamped::childframeid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TransformStamped.childframeid)
  return _internal_childframeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransformStamped::set_childframeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.childframeid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geometry_msg.TransformStamped.childframeid)
}
inline std::string* TransformStamped::mutable_childframeid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_childframeid();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TransformStamped.childframeid)
  return _s;
}
inline const std::string& TransformStamped::_internal_childframeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.childframeid_.Get();
}
inline void TransformStamped::_internal_set_childframeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.childframeid_.Set(value, GetArena());
}
inline std::string* TransformStamped::_internal_mutable_childframeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.childframeid_.Mutable( GetArena());
}
inline std::string* TransformStamped::release_childframeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TransformStamped.childframeid)
  return _impl_.childframeid_.Release();
}
inline void TransformStamped::set_allocated_childframeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.childframeid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.childframeid_.IsDefault()) {
          _impl_.childframeid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TransformStamped.childframeid)
}

// .geometry_msg.Transform transform = 3;
inline bool TransformStamped::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void TransformStamped::clear_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Transform& TransformStamped::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Transform&>(::geometry_msg::_Transform_default_instance_);
}
inline const ::geometry_msg::Transform& TransformStamped::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TransformStamped.transform)
  return _internal_transform();
}
inline void TransformStamped::unsafe_arena_set_allocated_transform(::geometry_msg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::geometry_msg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TransformStamped.transform)
}
inline ::geometry_msg::Transform* TransformStamped::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Transform* TransformStamped::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TransformStamped.transform)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::geometry_msg::Transform* TransformStamped::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::geometry_msg::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::geometry_msg::Transform* TransformStamped::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TransformStamped.transform)
  return _msg;
}
inline void TransformStamped::set_allocated_transform(::geometry_msg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Transform*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Transform*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transform_ = reinterpret_cast<::geometry_msg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TransformStamped.transform)
}

// -------------------------------------------------------------------

// Twist

// .geometry_msg.Vector3 linear = 1;
inline bool Twist::has_linear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_ != nullptr);
  return value;
}
inline void Twist::clear_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.linear_ != nullptr) _impl_.linear_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Vector3& Twist::_internal_linear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Vector3* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Vector3&>(::geometry_msg::_Vector3_default_instance_);
}
inline const ::geometry_msg::Vector3& Twist::linear() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Twist.linear)
  return _internal_linear();
}
inline void Twist::unsafe_arena_set_allocated_linear(::geometry_msg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Twist.linear)
}
inline ::geometry_msg::Vector3* Twist::release_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* released = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Vector3* Twist::unsafe_arena_release_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Twist.linear)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Vector3* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::geometry_msg::Vector3* Twist::_internal_mutable_linear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Vector3>(GetArena());
    _impl_.linear_ = reinterpret_cast<::geometry_msg::Vector3*>(p);
  }
  return _impl_.linear_;
}
inline ::geometry_msg::Vector3* Twist::mutable_linear() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Vector3* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Twist.linear)
  return _msg;
}
inline void Twist::set_allocated_linear(::geometry_msg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Vector3*>(_impl_.linear_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.linear_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Twist.linear)
}

// .geometry_msg.Vector3 angular = 2;
inline bool Twist::has_angular() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_ != nullptr);
  return value;
}
inline void Twist::clear_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.angular_ != nullptr) _impl_.angular_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Vector3& Twist::_internal_angular() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Vector3* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Vector3&>(::geometry_msg::_Vector3_default_instance_);
}
inline const ::geometry_msg::Vector3& Twist::angular() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.Twist.angular)
  return _internal_angular();
}
inline void Twist::unsafe_arena_set_allocated_angular(::geometry_msg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.Twist.angular)
}
inline ::geometry_msg::Vector3* Twist::release_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Vector3* released = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Vector3* Twist::unsafe_arena_release_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.Twist.angular)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Vector3* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::geometry_msg::Vector3* Twist::_internal_mutable_angular() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Vector3>(GetArena());
    _impl_.angular_ = reinterpret_cast<::geometry_msg::Vector3*>(p);
  }
  return _impl_.angular_;
}
inline ::geometry_msg::Vector3* Twist::mutable_angular() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Vector3* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:geometry_msg.Twist.angular)
  return _msg;
}
inline void Twist::set_allocated_angular(::geometry_msg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Vector3*>(_impl_.angular_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.angular_ = reinterpret_cast<::geometry_msg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.Twist.angular)
}

// -------------------------------------------------------------------

// TwistStamped

// .std_msg.Header header = 1;
inline bool TwistStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& TwistStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& TwistStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TwistStamped.header)
  return _internal_header();
}
inline void TwistStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TwistStamped.header)
}
inline ::std_msg::Header* TwistStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* TwistStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TwistStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* TwistStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* TwistStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TwistStamped.header)
  return _msg;
}
inline void TwistStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TwistStamped.header)
}

// .geometry_msg.Twist twist = 2;
inline bool TwistStamped::has_twist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.twist_ != nullptr);
  return value;
}
inline void TwistStamped::clear_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.twist_ != nullptr) _impl_.twist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::Twist& TwistStamped::_internal_twist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Twist* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Twist&>(::geometry_msg::_Twist_default_instance_);
}
inline const ::geometry_msg::Twist& TwistStamped::twist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TwistStamped.twist)
  return _internal_twist();
}
inline void TwistStamped::unsafe_arena_set_allocated_twist(::geometry_msg::Twist* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TwistStamped.twist)
}
inline ::geometry_msg::Twist* TwistStamped::release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Twist* released = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Twist* TwistStamped::unsafe_arena_release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TwistStamped.twist)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::geometry_msg::Twist* TwistStamped::_internal_mutable_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Twist>(GetArena());
    _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(p);
  }
  return _impl_.twist_;
}
inline ::geometry_msg::Twist* TwistStamped::mutable_twist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Twist* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TwistStamped.twist)
  return _msg;
}
inline void TwistStamped::set_allocated_twist(::geometry_msg::Twist* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Twist*>(_impl_.twist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Twist*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TwistStamped.twist)
}

// -------------------------------------------------------------------

// TwistWithCovariance

// .geometry_msg.Twist twist = 1;
inline bool TwistWithCovariance::has_twist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.twist_ != nullptr);
  return value;
}
inline void TwistWithCovariance::clear_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.twist_ != nullptr) _impl_.twist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geometry_msg::Twist& TwistWithCovariance::_internal_twist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::Twist* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::Twist&>(::geometry_msg::_Twist_default_instance_);
}
inline const ::geometry_msg::Twist& TwistWithCovariance::twist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TwistWithCovariance.twist)
  return _internal_twist();
}
inline void TwistWithCovariance::unsafe_arena_set_allocated_twist(::geometry_msg::Twist* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TwistWithCovariance.twist)
}
inline ::geometry_msg::Twist* TwistWithCovariance::release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Twist* released = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::Twist* TwistWithCovariance::unsafe_arena_release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TwistWithCovariance.twist)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geometry_msg::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::geometry_msg::Twist* TwistWithCovariance::_internal_mutable_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::Twist>(GetArena());
    _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(p);
  }
  return _impl_.twist_;
}
inline ::geometry_msg::Twist* TwistWithCovariance::mutable_twist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::Twist* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TwistWithCovariance.twist)
  return _msg;
}
inline void TwistWithCovariance::set_allocated_twist(::geometry_msg::Twist* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::Twist*>(_impl_.twist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::Twist*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.twist_ = reinterpret_cast<::geometry_msg::Twist*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TwistWithCovariance.twist)
}

// repeated double covariance = 2;
inline int TwistWithCovariance::_internal_covariance_size() const {
  return _internal_covariance().size();
}
inline int TwistWithCovariance::covariance_size() const {
  return _internal_covariance_size();
}
inline void TwistWithCovariance::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.covariance_.Clear();
}
inline double TwistWithCovariance::covariance(int index) const {
  // @@protoc_insertion_point(field_get:geometry_msg.TwistWithCovariance.covariance)
  return _internal_covariance().Get(index);
}
inline void TwistWithCovariance::set_covariance(int index, double value) {
  _internal_mutable_covariance()->Set(index, value);
  // @@protoc_insertion_point(field_set:geometry_msg.TwistWithCovariance.covariance)
}
inline void TwistWithCovariance::add_covariance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_covariance()->Add(value);
  // @@protoc_insertion_point(field_add:geometry_msg.TwistWithCovariance.covariance)
}
inline const ::google::protobuf::RepeatedField<double>& TwistWithCovariance::covariance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geometry_msg.TwistWithCovariance.covariance)
  return _internal_covariance();
}
inline ::google::protobuf::RepeatedField<double>* TwistWithCovariance::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geometry_msg.TwistWithCovariance.covariance)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_covariance();
}
inline const ::google::protobuf::RepeatedField<double>& TwistWithCovariance::_internal_covariance()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.covariance_;
}
inline ::google::protobuf::RepeatedField<double>* TwistWithCovariance::_internal_mutable_covariance() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.covariance_;
}

// -------------------------------------------------------------------

// TwistWithCovarianceStamped

// .std_msg.Header header = 1;
inline bool TwistWithCovarianceStamped::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::std_msg::Header& TwistWithCovarianceStamped::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::std_msg::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::std_msg::Header&>(::std_msg::_Header_default_instance_);
}
inline const ::std_msg::Header& TwistWithCovarianceStamped::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TwistWithCovarianceStamped.header)
  return _internal_header();
}
inline void TwistWithCovarianceStamped::unsafe_arena_set_allocated_header(::std_msg::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TwistWithCovarianceStamped.header)
}
inline ::std_msg::Header* TwistWithCovarianceStamped::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::std_msg::Header* TwistWithCovarianceStamped::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TwistWithCovarianceStamped.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::std_msg::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::std_msg::Header* TwistWithCovarianceStamped::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::std_msg::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::std_msg::Header*>(p);
  }
  return _impl_.header_;
}
inline ::std_msg::Header* TwistWithCovarianceStamped::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TwistWithCovarianceStamped.header)
  return _msg;
}
inline void TwistWithCovarianceStamped::set_allocated_header(::std_msg::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::std_msg::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TwistWithCovarianceStamped.header)
}

// .geometry_msg.TwistWithCovariance twist = 2;
inline bool TwistWithCovarianceStamped::has_twist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.twist_ != nullptr);
  return value;
}
inline void TwistWithCovarianceStamped::clear_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.twist_ != nullptr) _impl_.twist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::geometry_msg::TwistWithCovariance& TwistWithCovarianceStamped::_internal_twist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::geometry_msg::TwistWithCovariance* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::geometry_msg::TwistWithCovariance&>(::geometry_msg::_TwistWithCovariance_default_instance_);
}
inline const ::geometry_msg::TwistWithCovariance& TwistWithCovarianceStamped::twist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geometry_msg.TwistWithCovarianceStamped.twist)
  return _internal_twist();
}
inline void TwistWithCovarianceStamped::unsafe_arena_set_allocated_twist(::geometry_msg::TwistWithCovariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geometry_msg.TwistWithCovarianceStamped.twist)
}
inline ::geometry_msg::TwistWithCovariance* TwistWithCovarianceStamped::release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::TwistWithCovariance* released = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::geometry_msg::TwistWithCovariance* TwistWithCovarianceStamped::unsafe_arena_release_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:geometry_msg.TwistWithCovarianceStamped.twist)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::geometry_msg::TwistWithCovariance* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::geometry_msg::TwistWithCovariance* TwistWithCovarianceStamped::_internal_mutable_twist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry_msg::TwistWithCovariance>(GetArena());
    _impl_.twist_ = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(p);
  }
  return _impl_.twist_;
}
inline ::geometry_msg::TwistWithCovariance* TwistWithCovarianceStamped::mutable_twist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geometry_msg::TwistWithCovariance* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:geometry_msg.TwistWithCovarianceStamped.twist)
  return _msg;
}
inline void TwistWithCovarianceStamped::set_allocated_twist(::geometry_msg::TwistWithCovariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::geometry_msg::TwistWithCovariance*>(_impl_.twist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.twist_ = reinterpret_cast<::geometry_msg::TwistWithCovariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:geometry_msg.TwistWithCovarianceStamped.twist)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace geometry_msg


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto_2epb_2eh
